<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai&family=Chakra+Petch&display=swap"
        rel="stylesheet" />
    <title>‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô Language Learner</title>
    <link rel="icon" type="image/x-icon" href="/assets/bhasa/images/favicon.ico">
    <link rel="stylesheet" href="/assets/bhasa/stylesheet/bhasa.css">
</head>

<body data-theme="light">
    <header>
        <span lang="th" id="appTitle">‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô</span>
        <div id="headerControls">
            <button id="themeToggle" title="Toggle Day/Night" aria-label="Toggle theme">üåû</button>
            <button id="settingsBtn" title="Settings & Help" aria-label="Open settings">‚öôÔ∏è</button>
        </div>
    </header>
    <main>
        <div class="content-area" id="contentArea">
            <div class="selection-header">Text To Speech</div>

            <!-- Progress Bar -->
            <div style="margin: 0.5em 0;">
                <div class="progress-bar">
                    <div id="progressBar" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>

            <details class="topic-options-details" id="topicOptionsDetails">
                <summary>Topic & Language Options</summary>
                <div class="topic-options-content">
                    <div id="topicSelectionControls" class="topic-selection-controls">
                        <label>Topic: <select id="topicSelect" aria-label="Select topic"></select></label>
                        <label>Title: <select id="titleSelect" aria-label="Select title"></select></label>
                        <label>Example: <select id="exampleSelect" aria-label="Select example"></select></label>
                    </div>

                    <div class="language-controls">
                        <details>
                            <summary style="font-weight: bold;">Language Options</summary>
                            <div class="language-controls-content">
                                <!-- NEW: Dynamic Language Grid -->
                                <div class="language-controls-grid">
                                    <div class="language-grid">
                                        <div class="language-grid-header">Language</div>
                                        <div class="language-grid-header">Display</div>
                                        <div class="language-grid-header">Speak</div>
                                        <!-- Language rows will be dynamically inserted here -->
                                    </div>
                                </div>

                                <!-- Playback Delay -->
                                <div class="language-delay-row">
                                    <span class="delay-label">Reading delay (secs)</span>
                                    <input type="number" id="playbackDelay" class="delay-input" value="0.5" min="0.5"
                                        max="5.0" step="1.0" aria-label="Playback delay in seconds">
                                </div>
                            </div>
                        </details>
                    </div>
                </div>
            </details>

            <section id="exampleSec">
                <div id="exampleDisplay" aria-live="polite"></div>
                <div id="exampleControls" class="controls">
                    <div class="example-controls-row">
                        <button id="playBtn" aria-label="Play example" class="touch-target">‚ñ∂Ô∏è</button>
                        <button id="pauseBtn" aria-label="Pause example" class="touch-target">‚è∏Ô∏è</button>
                        <button id="restartBtn" aria-label="Restart example" class="touch-target">‚èÆÔ∏è</button>
                        <div class="example-number-container">
                            <span class="example-number-label">Example</span>
                            <span id="currentExampleNumber" class="example-number">1</span>
                        </div>
                        <button id="prevExample" aria-label="Previous example" class="touch-target">‚¨ÖÔ∏è</button>
                        <button id="nextExample" aria-label="Next example" class="touch-target">‚û°Ô∏è</button>
                    </div>
                </div>
            </section>

            <section id="quizSec">
                <h3>Practice Quiz</h3>

                <div id="quiz" aria-live="polite"></div>
                <div id="quizControls">
                    <!-- UPDATED: Dynamic Language selection -->
                    <div class="quiz-row quiz-row-top">
                        <div class="lang-option">
                            <label>Question Language:</label>
                            <div class="radio-group" id="questionLangGroup">
                                <!-- Dynamic radio buttons will be inserted here -->
                            </div>
                        </div>
                        <div class="lang-option">
                            <label>Answer Language:</label>
                            <div class="radio-group" id="answerLangGroup">
                                <!-- Dynamic radio buttons will be inserted here -->
                            </div>
                        </div>
                    </div>

                    <div class="quiz-row quiz-row-bottom">
                        <button id="prevQ" aria-label="Previous question" class="touch-target">‚¨ÖÔ∏è</button>
                        <button id="nextQ" aria-label="Next question" class="touch-target">‚û°Ô∏è</button>
                        <button id="retryQuiz" aria-label="Retry quiz" class="touch-target">üîÑ</button>
                        <span id="score">Score: 0/0</span>
                        <label>
                            <input type="checkbox" id="incorrectOnly" aria-label="Show only incorrect questions">
                            Incorrect Only
                        </label>
                    </div>
                </div>
            </section>
        </div>
        <div class="controls-area" id="controlsArea">
            <!-- Controls will be inserted here -->
        </div>
    </main>

    <!-- Screen reader announcements -->
    <div id="statusAnnouncement" aria-live="polite" aria-atomic="true"
        style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;"></div>

    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div style="text-align: center;">
            <div class="loading-spinner" style="border-top-color: white; margin: 0 auto 1em;"></div>
            <div>Loading...</div>
        </div>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const CONSTANTS = {
            STORAGE_KEYS: {
                THEME: 'theme',
                THAI_FONT: 'thaiFont',
                CURRENT_TOPIC: 'currentTopic',
                CURRENT_TITLE: 'currentTitle',
                CURRENT_EXAMPLE: 'currentExample',
                PLAYBACK_DELAY: 'playbackDelay',
                QUESTION_LANG: 'questionLang',
                ANSWER_LANG: 'answerLang'
            },
            DEFAULT_VALUES: {
                THEME: 'light',
                PLAYBACK_DELAY: '0.5',
                QUESTION_LANG: 'th-TH',
                ANSWER_LANG: 'en-US'
            },
            MAX_RETRIES: 3,
            RETRY_DELAY: 1000
        };

        // ==================== APP CONFIGURATION ====================
        const AppConfig = {
            data: null,
            availableLanguages: [],
            quizEnabledLanguages: [],

            async load() {
                try {
                    const response = await fetch('/assets/bhasa/bhasaSetup.json');
                    this.data = await response.json();
                    this.processLanguages();
                    return this.data;
                } catch (error) {
                    console.error('Failed to load app configuration:', error);
                    // Fallback to default configuration
                    this.data = this.getDefaultConfig();
                    this.processLanguages();
                    return this.data;
                }
            },

            processLanguages() {
                this.availableLanguages = Object.entries(this.data.languages).map(([code, config]) => ({
                    code,
                    ...config
                }));

                // DEBUG: Log all languages before filtering
                console.log('All languages before quiz filtering:', this.availableLanguages);

                this.quizEnabledLanguages = this.availableLanguages.filter(lang => {
                    const isEnabled = lang.quizEnabled;
                    console.log(`Language ${lang.code} (${lang.name}): quizEnabled = ${isEnabled}`);
                    return isEnabled;
                });

                // MANUAL OVERRIDE: Ensure Japanese is always included in quiz languages
                /*
                                const japaneseLang = this.availableLanguages.find(lang => lang.code === 'ja-JP');
                                if (japaneseLang && !this.quizEnabledLanguages.find(lang => lang.code === 'ja-JP')) {
                                    console.log('Manually adding Japanese to quiz languages');
                                    this.quizEnabledLanguages.push(japaneseLang);
                                }
                */
                console.log('Final quiz languages:', this.quizEnabledLanguages.map(l => l.code));
            },

            getDefaultConfig() {
                return {
                    app: {
                        name: "Bhasa Language Learner",
                        version: "2.0",
                        defaultTheme: "light",
                        supportedQuizModes: ["word"],
                        maxDisplayLanguages: 6,
                        defaultPlaybackDelay: 0.5
                    },
                    languages: {
                        "th-TH": {
                            name: "Thai",
                            nativeName: "‡πÑ‡∏ó‡∏¢",
                            fontFamily: "Noto Sans Thai, Tahoma, sans-serif",
                            rtl: false,
                            defaultDisplay: true,
                            defaultSpeak: true,
                            quizEnabled: true
                        },
                        "fa-IR": {
                            name: "Persian",
                            nativeName: "ŸÅÿßÿ±ÿ≥€å",
                            fontFamily: "Arial, sans-serif",
                            rtl: true,
                            defaultDisplay: false,
                            defaultSpeak: false,
                            quizEnabled: true
                        },
                        "en-US": {
                            name: "English",
                            nativeName: "English",
                            fontFamily: "Arial, sans-serif",
                            rtl: false,
                            defaultDisplay: false,
                            defaultSpeak: false,
                            quizEnabled: true
                        },
                        "ja-JP": {
                            name: "Japanese",
                            nativeName: "Êó•Êú¨Ë™û",
                            fontFamily: "Arial, sans-serif",
                            rtl: false,
                            defaultDisplay: false,
                            defaultSpeak: false,
                            quizEnabled: true
                        }
                    },
                    features: {
                        enableSearch: true,
                        enableProgressTracking: true,
                        enableTTS: true,
                        enableQuiz: true
                    }
                };
            },

            getLanguage(code) {
                return this.availableLanguages.find(lang => lang.code === code);
            },

            getDisplayLanguages() {
                return this.availableLanguages.filter(lang =>
                    Storage.loadBool(`display_${lang.code}`, lang.defaultDisplay)
                );
            },

            getSpeakLanguages() {
                // Languages with the Speak flag set (or the default from config)
                const speakChecked = (this.availableLanguages || []).filter(lang =>
                    Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak)
                );

                // Also include any languages that are displayed, so the user can hear them
                // even if the Speak checkbox was accidentally left unchecked.
                const displayLangs = this.getDisplayLanguages();

                // Merge the two arrays, removing duplicates
                const combined = [...new Set([...speakChecked, ...displayLangs])];
                return combined;
            },
        };

        // ==================== ERROR HANDLER ====================
        const ErrorHandler = {
            wrap: (fn, context = '') => {
                return (...args) => {
                    try {
                        return fn(...args);
                    } catch (error) {
                        console.error(`Error in ${context}:`, error);
                        ErrorHandler.showErrorToUser(error.message);
                        return null;
                    }
                };
            },

            showErrorToUser: (message) => {
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.innerHTML = `
    <strong>Something went wrong</strong>
    <p>${ErrorHandler.sanitizeHTML(message)}</p>
    <button onclick="this.parentElement.remove()" style="margin-top: 0.5em;">Dismiss</button>
    `;
                    contentArea.prepend(errorDiv);
                }
            },

            showSuccessMessage: (message) => {
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    const successDiv = document.createElement('div');
                    successDiv.className = 'success-message';
                    successDiv.innerHTML = `
    <strong>Success</strong>
    <p>${ErrorHandler.sanitizeHTML(message)}</p>
    <button onclick="this.parentElement.remove()" style="margin-top: 0.5em;">Dismiss</button>
    `;
                    contentArea.prepend(successDiv);
                }
            },

            sanitizeHTML: (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        };

        // ==================== UTILITIES ====================
        const Utils = {
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            throttle: (func, limit) => {
                let inThrottle;
                return function (...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            generateId: () => {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            },

            setLoadingState: (isLoading) => {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) {
                    overlay.style.display = isLoading ? 'flex' : 'none';
                }
            }
        };

        // ==================== STORAGE MANAGER ====================
        const Storage = {
            save: (key, value) => {
                try {
                    localStorage.setItem(key, value);
                } catch (error) {
                    console.error('Storage error:', error);
                }
            },

            load: (key, defaultValue = '') => {
                try {
                    return localStorage.getItem(key) || defaultValue;
                } catch (error) {
                    console.error('Storage error:', error);
                    return defaultValue;
                }
            },

            loadInt: (key, defaultValue = 0) => {
                const value = Storage.load(key, defaultValue.toString());
                return parseInt(value, 10);
            },

            loadBool: (key, defaultValue = false) => {
                const value = Storage.load(key, defaultValue ? '1' : '0');
                return value === '1';
            },

            remove: (key) => {
                try {
                    localStorage.removeItem(key);
                } catch (error) {
                    console.error('Storage error:', error);
                }
            }
        };

        // ==================== NETWORK MANAGER ====================
        const NetworkManager = {
            async fetchWithRetry(url, retries = CONSTANTS.MAX_RETRIES, delay = CONSTANTS.RETRY_DELAY) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) return response;
                        if (response.status === 404) {
                            throw new Error(`File not found: ${url}`);
                        }
                        throw new Error(`HTTP ${response.status}`);
                    } catch (error) {
                        if (i === retries - 1) throw error;
                        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                    }
                }
            },

            async fetchJSON(url) {
                try {
                    const response = await this.fetchWithRetry(url);
                    return await response.json();
                } catch (error) {
                    console.warn(`Failed to load ${url}:`, error.message);
                    // Return empty/default data instead of throwing
                    if (url.includes('topicList.json')) {
                        return this.getDefaultTopicList();
                    }
                    if (url.includes('bhasaSetup.json')) {
                        return AppConfig.getDefaultConfig();
                    }
                    throw error; // Re-throw for topic files
                }
            },

            getDefaultTopicList() {
                return [
                    {
                        topicFilename: "greetings.json",
                        topic: "Greetings",
                        description: "Basic greetings and introductions",
                        languageCount: 4,
                        exampleCount: 5,
                        difficulty: "beginner"
                    }
                ];
            }
        };

        // ==================== SCREEN READER ANNOUNCER ====================
        const ScreenReader = {
            announce: (message, priority = 'polite') => {
                const announcement = document.getElementById('statusAnnouncement');
                if (announcement) {
                    announcement.setAttribute('aria-live', priority);
                    announcement.textContent = message;
                    // Clear after announcement
                    setTimeout(() => {
                        announcement.textContent = '';
                    }, 1000);
                }
            }
        };

        // ==================== ENHANCED TTS MANAGER ====================
        const TTSManager = {
            supportedVoices: [],
            testResults: {},
            voiceCache: new Map(),

            initialize() {
                this.loadVoices();
                speechSynthesis.addEventListener('voiceschanged', () => {
                    this.loadVoices();
                });
            },

            loadVoices() {
                this.supportedVoices = speechSynthesis.getVoices();
                this.voiceCache.clear();
            },

            isSupported() {
                return 'speechSynthesis' in window && typeof SpeechSynthesisUtterance !== 'undefined';
            },

            getLanguageVoices(lang) {
                return this.supportedVoices.filter(voice =>
                    voice.lang.startsWith(lang) || voice.lang.includes(lang)
                );
            },

            hasLanguageSupport(lang) {
                return this.getLanguageVoices(lang).length > 0;
            },

            testLanguage(lang, text) {
                return new Promise((resolve) => {
                    if (!this.isSupported()) {
                        resolve({ success: false, error: 'TTS not supported' });
                        return;
                    }

                    if (!this.hasLanguageSupport(lang)) {
                        resolve({ success: false, error: `No ${lang} voices available` });
                        return;
                    }

                    try {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.lang = lang;
                        utterance.volume = 0.7;

                        utterance.onend = () => {
                            resolve({ success: true, voices: this.getLanguageVoices(lang) });
                        };

                        utterance.onerror = (error) => {
                            resolve({ success: false, error: this.getFriendlyError(error.error) });
                        };

                        speechSynthesis.speak(utterance);
                    } catch (error) {
                        resolve({ success: false, error: error.message });
                    }
                });
            },

            async comprehensiveTest() {
                const tests = AppConfig.availableLanguages
                    .filter(lang => lang.defaultSpeak)
                    .map(lang => ({
                        lang: lang.code,
                        text: this.getTestText(lang.code),
                        name: lang.name
                    }));

                this.testResults = {};
                let allPassed = true;

                for (const test of tests) {
                    const result = await this.testLanguage(test.lang, test.text);
                    this.testResults[test.lang] = {
                        ...result,
                        name: test.name,
                        text: test.text
                    };

                    if (!result.success) {
                        allPassed = false;
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                return allPassed;
            },

            getTestText(langCode) {
                const texts = {
                    'th-TH': '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏û‡∏π‡∏î‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢',
                    'fa-IR': 'ÿ≥ŸÑÿßŸÖÿå ÿß€åŸÜ ÿ™ÿ≥ÿ™ ⁄ØŸÅÿ™ÿßÿ± ŸÅÿßÿ±ÿ≥€å ÿßÿ≥ÿ™',
                    'en-US': 'Hello, this is English text-to-speech',
                    'zh-CN': '‰Ω†Â•ΩÔºåËøôÊòØ‰∏≠ÊñáÊñáÊú¨ËΩ¨ËØ≠Èü≥ÊµãËØï',
                    'ja-JP': '„Åì„Çì„Å´„Å°„ÅØ„ÄÅ„Åì„Çå„ÅØÊó•Êú¨Ë™û„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË™≠„Åø‰∏ä„Åí„ÉÜ„Çπ„Éà„Åß„Åô'
                };
                return texts[langCode] || `Test for ${langCode}`;
            },

            speak(text, lang, onEnd) {
                if (!text) return;

                const sanitizedText = ErrorHandler.sanitizeHTML(text);
                if (!sanitizedText) return;

                speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(sanitizedText);
                utterance.lang = lang;
                utterance.volume = 0.8;
                utterance.rate = 0.9;
                utterance.pitch = 1.0;

                if (onEnd) utterance.onend = onEnd;

                speechSynthesis.speak(utterance);
                ScreenReader.announce(`Speaking: ${sanitizedText.substring(0, 50)}...`);
            },

            cancel() {
                speechSynthesis.cancel();
                ScreenReader.announce('Speech cancelled');
            },

            pause() {
                speechSynthesis.pause();
                ScreenReader.announce('Speech paused');
            },

            resume() {
                speechSynthesis.resume();
                ScreenReader.announce('Speech resumed');
            },

            getFriendlyError(error) {
                const errorMap = {
                    'not-allowed': 'Microphone access denied. Please check browser permissions.',
                    'network': 'Network error. Please check your internet connection.',
                    'audio-busy': 'Audio device is busy. Please try again.',
                    'audio-hardware': 'Audio hardware error. Please check your audio devices.',
                    'synthesis-failed': 'Speech synthesis failed. Please try again.',
                    'synthesis-unavailable': 'Speech synthesis unavailable for this language.'
                };
                return errorMap[error] || `An unexpected error occurred: ${error}`;
            },

            getSetupInstructions() {
                return `
    <div class="tts-setup-steps">
        <h4>Text-to-Speech Setup Instructions</h4>
        <div class="tts-step">
            <strong>Step 1: Install Language Packs</strong>
            <p>Go to your device settings and install the required language packs for:</p>
            <ul>
                ${AppConfig.availableLanguages.map(lang =>
                    `<li><strong>${lang.name}:</strong> Search for "${lang.name} language pack" in your device settings</li>`
                ).join('')}
            </ul>
        </div>
        <div class="tts-step">
            <strong>Step 2: Browser TTS Setup</strong>
            <p>In your browser settings:</p>
            <ul>
                <li>Chrome: Settings ‚Üí Advanced ‚Üí Accessibility ‚Üí Text-to-Speech</li>
                <li>Firefox: Preferences ‚Üí General ‚Üí Language ‚Üí Text-to-Speech</li>
                <li>Safari: System Preferences ‚Üí Accessibility ‚Üí Speech</li>
            </ul>
        </div>
        <div class="tts-step">
            <strong>Step 3: Enable Voices</strong>
            <p>Make sure the voices are enabled and set as default in your system's text-to-speech settings.</p>
        </div>
    </div>
    `;
            },

            getStatusMessage() {
                const supportedLanguages = AppConfig.availableLanguages.filter(lang =>
                    this.hasLanguageSupport(lang.code)
                );

                if (!this.isSupported()) {
                    return {
                        type: 'error',
                        title: 'TTS Not Supported',
                        message: 'Your browser does not support Text-to-Speech. Please use a modern browser like Chrome, Firefox, or Edge.'
                    };
                }

                if (supportedLanguages.length === 0) {
                    return {
                        type: 'error',
                        title: 'No TTS Voices Available',
                        message: 'No text-to-speech voices are available. Please install language packs following the instructions below.'
                    };
                }

                const availableNames = supportedLanguages.map(lang => lang.name);
                const missingLanguages = AppConfig.availableLanguages
                    .filter(lang => !this.hasLanguageSupport(lang.code))
                    .map(lang => lang.name);

                if (missingLanguages.length > 0) {
                    return {
                        type: 'warning',
                        title: 'Partial TTS Support',
                        message: `Available: ${availableNames.join(', ')}. Missing: ${missingLanguages.join(', ')}. Some features may not work properly.`
                    };
                }

                return {
                    type: 'success',
                    title: 'TTS Fully Supported',
                    message: `All languages are available: ${availableNames.join(', ')}. Text-to-speech is ready to use.`
                };
            }
        };

        // ==================== PROGRESS TRACKER ====================
        const ProgressTracker = {
            saveProgress: ErrorHandler.wrap((topicId, titleIndex, exampleIndex, score) => {
                const progress = {
                    lastAccessed: new Date().toISOString(),
                    currentTitle: titleIndex,
                    currentExample: exampleIndex,
                    scores: ProgressTracker.getScores(topicId),
                    completedExamples: ProgressTracker.getCompletedExamples(topicId)
                };

                progress.scores[`${titleIndex}-${exampleIndex}`] = score;
                progress.completedExamples.add(`${titleIndex}-${exampleIndex}`);

                Storage.save(`progress-${topicId}`, JSON.stringify(progress));
            }, 'ProgressTracker.saveProgress'),

            getProgress: ErrorHandler.wrap((topicId) => {
                const progress = Storage.load(`progress-${topicId}`);
                return progress ? JSON.parse(progress) : {
                    lastAccessed: null,
                    currentTitle: 0,
                    currentExample: 0,
                    scores: {},
                    completedExamples: new Set()
                };
            }, 'ProgressTracker.getProgress'),

            getCompletionPercentage: ErrorHandler.wrap((topicId, topicData) => {
                const progress = ProgressTracker.getProgress(topicId);
                const totalExamples = topicData.titles?.reduce((total, title) =>
                    total + (title.examples?.length || 0), 0) || 0;

                if (totalExamples === 0) return 0;

                return Math.round((progress.completedExamples.size / totalExamples) * 100);
            }, 'ProgressTracker.getCompletionPercentage'),

            getScores: (topicId) => {
                const progress = ProgressTracker.getProgress(topicId);
                return progress.scores || {};
            },

            getCompletedExamples: (topicId) => {
                const progress = ProgressTracker.getProgress(topicId);
                return new Set(progress.completedExamples || []);
            }
        };

        // ==================== APPLICATION STATE ====================
        const AppState = {
            topics: [],
            currentTopic: null,
            currentTitle: 0,
            currentExample: 0,
            isPlaying: false,
            currentWordIndex: 0,
            lastHighlightedIndex: null,

            initialize() {
                this.currentTopic = Storage.load(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC, '');
                this.currentTitle = Storage.loadInt(CONSTANTS.STORAGE_KEYS.CURRENT_TITLE, 0);
                this.currentExample = Storage.loadInt(CONSTANTS.STORAGE_KEYS.CURRENT_EXAMPLE, 0);
            },

            saveNavigation() {
                Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_TITLE, this.currentTitle);
                Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_EXAMPLE, this.currentExample);

                if (this.currentTopic?.topicFilename) {
                    ProgressTracker.saveProgress(
                        this.currentTopic.topicFilename,
                        this.currentTitle,
                        this.currentExample,
                        QuizSystem.score
                    );
                }
            },

            getCurrentExample() {
                try {
                    const currentTitle = this.currentTopic?.titles?.[this.currentTitle];
                    const examples = currentTitle?.examples;
                    const example = examples?.[this.currentExample];

                    console.log('Current example data:', example);

                    if (!example) {
                        console.warn('No example found at current position');
                        return [];
                    }

                    // If it's already in word array format, return as-is
                    if (Array.isArray(example)) {
                        return example;
                    }

                    // Handle object format with translations
                    return example; // Let PlaybackController handle the conversion
                } catch (error) {
                    console.error('Error getting current example:', error);
                    return [];
                }
            },

            /*
                        convertTranslationsToWordArray(translations) {
                            const languages = Object.keys(translations);
                            const wordArrays = languages.map(lang => {
                                const content = translations[lang];
                                return Array.isArray(content) ? content : [content];
                            });
            
                            const maxLength = Math.max(...wordArrays.map(arr => arr.length));
                            const result = [];
            
                            for (let i = 0; i < maxLength; i++) {
                                const word = {};
                                languages.forEach((lang, langIndex) => {
                                    word[lang] = wordArrays[langIndex][i] || '';
                                });
                                result.push(word);
                            }
            
                            return result;
                        }
                        */

        };

        // ========== UI COMPONENTS ==========
        const ThemeManager = {
            init() {
                const themeToggle = document.getElementById('themeToggle');
                themeToggle.addEventListener('click', () => this.toggle());
                this.set(Storage.load(CONSTANTS.STORAGE_KEYS.THEME, CONSTANTS.DEFAULT_VALUES.THEME));
            },

            set(theme) {
                document.body.dataset.theme = theme;
                document.getElementById('themeToggle').textContent = theme === 'light' ? 'üåû' : 'üåô';
                document.getElementById('themeToggle').setAttribute('aria-label',
                    theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode');
                Storage.save(CONSTANTS.STORAGE_KEYS.THEME, theme);
                ScreenReader.announce(`Theme set to ${theme} mode`);
            },

            toggle() {
                this.set(document.body.dataset.theme === 'light' ? 'dark' : 'light');
            }
        };

        const FontManager = {
            init() {
                this.apply();
            },

            apply() {
                const font = Storage.load(CONSTANTS.STORAGE_KEYS.THAI_FONT, '');

                // Apply to body or a container element to cascade down
                const body = document.body;

                // Remove all font classes first
                body.classList.remove('thai-font', 'tahoma', 'noto', 'chakra');

                // Add base class and specific font class
                body.classList.add('thai-font');
                if (font === 'Tahoma') body.classList.add('tahoma');
                if (font === 'Noto Sans Thai') body.classList.add('noto');
                if (font === 'Chakra Petch') body.classList.add('chakra');

                // Also apply directly to app title for redundancy
                const appTitle = document.getElementById('appTitle');
                if (appTitle) {
                    appTitle.classList.add('thai-font');
                    appTitle.classList.remove('tahoma', 'noto', 'chakra');
                    if (font === 'Tahoma') appTitle.classList.add('tahoma');
                    if (font === 'Noto Sans Thai') appTitle.classList.add('noto');
                    if (font === 'Chakra Petch') appTitle.classList.add('chakra');
                }

                // Apply to font preview
                const fontPreview = document.getElementById('fontPreview');
                if (fontPreview) {
                    fontPreview.className = 'font-preview thai-font';
                    if (font === 'Tahoma') fontPreview.classList.add('tahoma');
                    if (font === 'Noto Sans Thai') fontPreview.classList.add('noto');
                    if (font === 'Chakra Petch') fontPreview.classList.add('chakra');
                }

                // Force re-render of example display if it exists
                const exampleDisplay = document.getElementById('exampleDisplay');
                if (exampleDisplay && exampleDisplay.innerHTML) {
                    // This will trigger the CSS to apply to the Thai text
                    const currentExample = AppState.getCurrentExample();
                    if (currentExample && currentExample.length > 0) {
                        ExampleRenderer.render(currentExample);
                    }
                }
            }
        };

        // ========== LANGUAGE MANAGER ==========
        const LanguageManager = {
            init() {
                // ---------------------------------------------------------
                // 1Ô∏è‚É£  Store the master list of languages from AppConfig
                // ---------------------------------------------------------
                // AppConfig.availableLanguages is populated when the
                // configuration JSON is loaded (bhasaSetup.json).  We keep a
                // local copy here so that the manager can work independently.
                this.availableLanguages = AppConfig.availableLanguages || [];

                // ---------------------------------------------------------
                // 2Ô∏è‚É£  Render UI and bind events (unchanged logic)
                // ---------------------------------------------------------
                this.renderLanguageControls();
                this.renderQuizLanguageOptions();
                this.bindLanguageEvents();
            },

            renderLanguageControls() {
                const languageGrid = document.querySelector('.language-grid');
                if (!languageGrid) return;

                // Clear existing rows (keep headers)
                const existingRows = languageGrid.querySelectorAll('.language-grid-row');
                existingRows.forEach(row => row.remove());

                AppConfig.availableLanguages.forEach(language => {
                    const row = document.createElement('div');
                    row.className = 'language-grid-row';

                    const isDisplayEnabled = Storage.loadBool(`display_${language.code}`, language.defaultDisplay);
                    const isSpeakEnabled = Storage.loadBool(`speak_${language.code}`, language.defaultSpeak);

                    row.innerHTML = `
    <div class="language-name">
        ${language.name} (${language.nativeName})
    </div>
    <div class="language-checkbox-cell">
        <input type="checkbox" id="display_${language.code}"
            ${isDisplayEnabled ? 'checked' : ''}
            aria-label="Display ${language.name}">
    </div>
    <div class="language-checkbox-cell">
        <input type="checkbox" id="speak_${language.code}"
            ${isSpeakEnabled ? 'checked' : ''}
            aria-label="Speak ${language.name}">
    </div>
    `;

                    languageGrid.appendChild(row);
                });
            },

            renderQuizLanguageOptions() {
                const questionGroup = document.getElementById('questionLangGroup');
                const answerGroup = document.getElementById('answerLangGroup');

                if (!questionGroup || !answerGroup) return;

                questionGroup.innerHTML = '';
                answerGroup.innerHTML = '';

                const quizLanguages = AppConfig.quizEnabledLanguages;

                console.log('Quiz Enabled Languages:', quizLanguages);

                const savedQuestionLang = Storage.load(CONSTANTS.STORAGE_KEYS.QUESTION_LANG, CONSTANTS.DEFAULT_VALUES.QUESTION_LANG);
                const savedAnswerLang = Storage.load(CONSTANTS.STORAGE_KEYS.ANSWER_LANG, CONSTANTS.DEFAULT_VALUES.ANSWER_LANG);

                quizLanguages.forEach(language => {
                    console.log('Adding quiz language:', language.code, language.name);

                    // Question language radio
                    const questionLabel = document.createElement('label');
                    questionLabel.innerHTML = `
    <input type="radio" name="questionLang" value="${language.code}"
        ${savedQuestionLang === language.code ? 'checked' : ''}>
        ${language.name}
        `;
                    questionGroup.appendChild(questionLabel);

                    // Answer language radio
                    const answerLabel = document.createElement('label');
                    answerLabel.innerHTML = `
        <input type="radio" name="answerLang" value="${language.code}"
            ${savedAnswerLang === language.code ? 'checked' : ''}>
            ${language.name}
            `;
                    answerGroup.appendChild(answerLabel);
                });

                // ADD THIS: Re-bind quiz language events after rendering
                this.bindQuizLanguageEvents();
            },

            bindLanguageEvents() {
                // Language checkbox events
                AppConfig.availableLanguages.forEach(language => {
                    const displayCheckbox = document.getElementById(`display_${language.code}`);
                    const speakCheckbox = document.getElementById(`speak_${language.code}`);

                    // ------------------------------
                    // DISPLAY checkbox ‚Äì unchanged
                    // ------------------------------
                    if (displayCheckbox) {
                        displayCheckbox.addEventListener('change', (e) => {
                            Storage.save(`display_${language.code}`, e.target.checked ? '1' : '0');
                            AppController.renderExample();               // re‚Äërender with new visibility
                            ScreenReader.announce(`${language.name} display ${e.target.checked ? 'enabled' : 'disabled'}`);
                        });
                    }

                    // ------------------------------
                    // SPEAK checkbox ‚Äì **new logic**
                    // ------------------------------
                    if (speakCheckbox) {
                        speakCheckbox.addEventListener('change', (e) => {
                            const speakOn = e.target.checked;
                            Storage.save(`speak_${language.code}`, speakOn ? '1' : '0');
                            ScreenReader.announce(`${language.name} speech ${speakOn ? 'enabled' : 'disabled'}`);

                            // *** NEW PART ***
                            // If the user enables SPEAK for a language, also enable DISPLAY
                            // so that the word‚Äëpair span actually exists in the DOM.
                            if (speakOn) {
                                // 1Ô∏è‚É£  Persist the display flag
                                Storage.save(`display_${language.code}`, '1');

                                // 2Ô∏è‚É£  Update the UI checkbox (if it exists)
                                if (displayCheckbox) {
                                    displayCheckbox.checked = true;
                                }

                                // 3Ô∏è‚É£  Re‚Äërender the current example so the new language column appears
                                AppController.renderExample();
                            }
                        });
                    }
                });

                // Bind quiz language events (unchanged ‚Äì keep existing logic)
                this.bindQuizLanguageEvents();
            },

            // NEW METHOD: Bind quiz language change events
            bindQuizLanguageEvents() {
                // Quiz question language radio events
                document.querySelectorAll('input[name="questionLang"]').forEach(radio => {
                    // Remove any existing event listeners to prevent duplicates
                    radio.replaceWith(radio.cloneNode(true));
                });

                document.querySelectorAll('input[name="questionLang"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.QUESTION_LANG, e.target.value);
                        const lang = AppConfig.getLanguage(e.target.value);
                        ScreenReader.announce(`Question language set to ${lang?.name || e.target.value}`);

                        // ADD THIS: Refresh the quiz when question language changes
                        QuizSystem.refreshQuiz();
                    });
                });

                // Quiz answer language radio events
                document.querySelectorAll('input[name="answerLang"]').forEach(radio => {
                    // Remove any existing event listeners to prevent duplicates
                    radio.replaceWith(radio.cloneNode(true));
                });

                document.querySelectorAll('input[name="answerLang"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.ANSWER_LANG, e.target.value);
                        const lang = AppConfig.getLanguage(e.target.value);
                        ScreenReader.announce(`Answer language set to ${lang?.name || e.target.value}`);

                        // ADD THIS: Refresh the quiz when answer language changes
                        QuizSystem.refreshQuiz();
                    });
                });
            },

            getDisplayLanguages() {
                return AppConfig.getDisplayLanguages();
            },

            /**
             * Return the list of languages that should be spoken.
             *
             * 1Ô∏è‚É£  First honour the explicit ‚ÄúSpeak‚Äù check‚Äëboxes (the orange column).
             * 2Ô∏è‚É£  If the user hasn‚Äôt checked any Speak box, fall back to the
             *     languages that are currently displayed (the green column).
             *
             * This makes the player behave intuitively: if you turn a language
             * on for reading, it will also be spoken unless you explicitly
             * disable the Speak flag.
             */
            getSpeakLanguages() {
                // Languages with the Speak flag set (or the default from config)
                const speakChecked = (this.availableLanguages || []).filter(lang =>
                    Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak)
                );

                // If the user selected none, fall back to the displayed set
                if (speakChecked.length === 0) {
                    return this.getDisplayLanguages();
                }

                return speakChecked;
            },

            getQuizLanguages() {
                return AppConfig.quizEnabledLanguages;
            }
        };

        const SettingsManager = {
            show() {
                const contentArea = document.getElementById('contentArea');
                const controlsArea = document.getElementById('controlsArea');
                contentArea.innerHTML = this.getSettingsHTML();
                controlsArea.innerHTML = '';
                this.bindSettingsEvents();
                this.showInitialTTSStatus();
            },

            getSettingsHTML() {
                return `
            <div style="display: flex; justify-content: space-between; align-items: center;
                                background: #00247D; color: white; padding: 0.5em 1em; border-radius: 8px;">
                <h2 style="margin: 0;">Settings & Help</h2>
                <button id="closeX" aria-label="Close settings" style="background: #666; color: white; border: none; padding: 0.5em; border-radius: 4px; cursor: pointer;">‚ùå</button>
            </div>

            <div class="settings-content" style="padding: 1em;">
                <div class="settings-font-controls">
                    <label style="margin: 0;">
                        Thai Font:
                        <select id="settingsThaiFont" aria-label="Select Thai font">
                            <option value="">Default</option>
                            <option value="Tahoma">Tahoma</option>
                            <option value="Noto Sans Thai">Noto Sans Thai</option>
                            <option value="Chakra Petch">Chakra Petch</option>
                        </select>
                    </label>
                </div>
                <div class="font-preview" id="fontPreview" aria-live="polite">‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (Thai Text Sample)</div>

                <div class="settings-section">
                    <h3>Text-to-Speech Setup</h3>
                    <p>This App uses Text To Speech. Search in your device and your browser settings for languages and install the required language packs and enable Text To Speech. Then try the Test TTS button for more specific help for your device.</p>

                    <button id="checkTTS" class="settings-button" style="padding: 0.8em 1.5em; background: #00247D; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 1em 0;">
                        üîä Test TTS Setup & Language Support
                    </button>

                    <div id="ttsStatus"></div>
                    <div id="ttsSetupInstructions"></div>
                    <div id="languageTests"></div>
                </div>

                <div class="settings-section">
                    <details class="keyboard-shortcuts-panel">
                        <summary style="font-weight: bold; font-size: 1.1em; cursor: pointer;">Keyboard Shortcuts</summary>
                        <div class="keyboard-shortcuts">
                            <div class="shortcut-item">
                                <span>Play/Pause</span>
                                <kbd class="shortcut-key">Space</kbd>
                            </div>
                            <div class="shortcut-item">
                                <span>Next Example</span>
                                <kbd class="shortcut-key">‚Üí</kbd>
                            </div>
                            <div class="shortcut-item">
                                <span>Previous Example</span>
                                <kbd class="shortcut-key">‚Üê</kbd>
                            </div>
                            <div class="shortcut-item">
                                <span>Restart</span>
                                <kbd class="shortcut-key">R</kbd>
                            </div>
                            <div class="shortcut-item">
                                <span>Next Question</span>
                                <kbd class="shortcut-key">N</kbd>
                            </div>
                            <div class="shortcut-item">
                                <span>Settings</span>
                                <kbd class="shortcut-key">S</kbd>
                            </div>
                        </div>
                    </details>
                </div>

                <div style="margin-top: 2em; padding-top: 1em; border-top: 1px solid var(--border-light);">
                    <button id="closeBtn" style="padding: 0.6em 1.2em; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">Close Settings</button>
                </div>
            </div>`;
            },

            bindSettingsEvents() {
                document.getElementById('closeX').addEventListener('click', this.close);
                document.getElementById('closeBtn').addEventListener('click', this.close);
                document.getElementById('checkTTS').addEventListener('click', () => this.performTTSCheck());

                const settingsThaiFont = document.getElementById('settingsThaiFont');
                if (settingsThaiFont) {
                    settingsThaiFont.value = Storage.load(CONSTANTS.STORAGE_KEYS.THAI_FONT, '');
                    settingsThaiFont.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.THAI_FONT, e.target.value);
                        FontManager.apply(); // Apply immediately when font changes
                        ScreenReader.announce(`Thai font changed to ${e.target.value || 'default'}`);
                    });
                }
            },

            close() {
                const contentArea = document.getElementById('contentArea');
                const controlsArea = document.getElementById('controlsArea');

                contentArea.innerHTML = AppController.getMainHTML();
                controlsArea.innerHTML = AppController.getControlsHTML();

                AppController.bindUIElements();
                AppController.restoreSettings();
                AppController.loadTopics();
                ScreenReader.announce('Settings closed, returning to main view');
            },

            showInitialTTSStatus() {
                const status = TTSManager.getStatusMessage?.();
                this.showTTSStatus(status);

                if (status?.type !== 'success') {
                    const instructions = TTSManager.getSetupInstructions?.();
                    document.getElementById('ttsSetupInstructions').innerHTML = instructions;
                }
            },

            async performTTSCheck() {
                const ttsStatus = document.getElementById('ttsStatus');
                const checkBtn = document.getElementById('checkTTS');
                const languageTests = document.getElementById('languageTests');

                checkBtn.innerHTML = '<span class="loading-spinner"></span> Testing TTS...';
                checkBtn.disabled = true;
                ttsStatus.innerHTML = '';
                languageTests.innerHTML = '';

                const testPassed = await TTSManager.comprehensiveTest();
                this.showLanguageTestResults();

                if (!testPassed) {
                    const instructions = TTSManager.getSetupInstructions?.();
                    document.getElementById('ttsSetupInstructions').innerHTML = instructions;
                }

                checkBtn.innerHTML = '‚úÖ TTS Test Complete';
                checkBtn.disabled = false;

                const finalStatus = TTSManager.getStatusMessage?.();
                this.showTTSStatus(finalStatus);
            },

            showTTSStatus(status) {
                const ttsStatus = document.getElementById('ttsStatus');
                if (!status || !ttsStatus) return;

                const statusClass = `tts-status-${status.type === 'warning' ? 'info' : status.type}`;
                ttsStatus.innerHTML = `
            <div class="tts-status-container ${statusClass}">
                <h4 style="margin: 0 0 0.5em 0;">${status.title}</h4>
                <p style="margin: 0;">${status.message}</p>
            </div>
            `;
            },

            showLanguageTestResults() {
                const languageTests = document.getElementById('languageTests');
                const results = TTSManager.testResults;

                if (!languageTests || Object.keys(results).length === 0) return;

                let html = `<h4>Language Test Results:</h4><div class="tts-language-check">`;

                for (const [lang, result] of Object.entries(results)) {
                    const language = AppConfig.getLanguage(lang);
                    const icon = result.success ? '‚úÖ' : '‚ùå';
                    const resultClass = result.success ? 'success-check' : 'error-cross';
                    const voices = result.voices ? result.voices.map(v => v.name).join(', ') : 'No voices';

                    html += `
                <div style="flex: 1; min-width: 200px; padding: 1em; background: rgba(0,0,0,0.05); border-radius: 8px;">
                    <div style="font-weight: bold;">${icon} ${language?.name || lang}</div>
                    <div class="test-result ${resultClass}">
                        ${result.success ?
                            `<div class="success-list">Working - Available voices:<br>${voices}</div>` :
                            `Failed: ${result.error}. ${this.getLanguageSpecificHelp(lang, result.error)}`
                        }
                    </div>
                    <button onclick="testSingleLanguage('${lang}', '${result.text}')"
                        class="language-test"
                        style="margin-top: 0.5em;">
                        Test ${language?.name || lang} Again
                    </button>
                </div>
                `;
                }

                html += `</div>`;
                languageTests.innerHTML = html;
            },

            getLanguageSpecificHelp(lang, error) {
                const language = AppConfig.getLanguage(lang);
                const helpMessages = {
                    'th-TH': `To fix Thai TTS: Install Thai language pack in system settings, then restart browser.`,
                    'fa-IR': `To fix Persian TTS: Install Persian/Farsi language pack in system settings.`,
                    'en-US': `To fix English TTS: Check system language settings and ensure English TTS is enabled.`,
                    'ja-JP': `To fix Japanese TTS: Install Japanese language pack in system settings and enable Japanese text-to-speech.`
                };

                return helpMessages[lang] || `Please check your system language settings and install the ${language?.name || lang} language pack.`;
            }
        };

        // Global function for testing individual languages
        window.testSingleLanguage = async function (lang, text) {
            const language = AppConfig.getLanguage(lang);
            const result = await TTSManager.testLanguage(lang, text);
            alert(`${language?.name || lang} TTS Test: ${result.success ? 'SUCCESS' : 'FAILED'}\n${result.success ? 'Voice is working properly' : 'Error: ' + result.error}`);
        };

        // ========== TOPIC MANAGEMENT ==========
        const TopicManager = {
            cache: new Map(),

            async loadTopicList() {
                try {
                    const topicList = await NetworkManager.fetchJSON('/assets/bhasa/topics/topicList.json');
                    return topicList.map(topic => ({
                        topicFilename: topic.topicFilename,
                        topic: topic.topic,
                        description: topic.description,
                        languageCount: topic.languageCount,
                        exampleCount: topic.exampleCount,
                        difficulty: topic.difficulty
                    }));
                } catch (error) {
                    console.error('Error loading topic list:', error);
                    ErrorHandler.showErrorToUser('Failed to load topics. Please check your connection.');
                    return [];
                }
            },

            async loadTopic(filename) {
                if (this.cache.has(filename)) {
                    return this.cache.get(filename);
                }

                try {
                    const topicData = await NetworkManager.fetchJSON(`/assets/bhasa/topics/${filename}`);
                    const processedData = this.processTopicData(topicData);
                    this.cache.set(filename, processedData);
                    return processedData;
                } catch (error) {
                    console.error('Error loading topic:', error);
                    throw error;
                }
            },

            processTopicData(topicData) {
                // Handle both old and new format for backward compatibility during transition
                const isNewFormat = topicData.metadata && topicData.titles;

                if (isNewFormat) {
                    return {
                        topic: topicData.metadata.topic,
                        description: topicData.metadata.description,
                        titles: topicData.titles.map(titleItem => ({
                            title: titleItem.title,
                            description: titleItem.description,
                            examples: titleItem.examples.map(example => ({
                                // Support both new translations object and old flat structure
                                ...example.translations,
                                translations: example.translations,
                                metadata: example.metadata,
                                id: example.id
                            }))
                        })),
                        metadata: topicData.metadata
                    };
                } else {
                    // Old format - convert to new structure
                    return {
                        topic: topicData.topic,
                        titles: topicData.titles?.map(titleItem => ({
                            title: titleItem.title,
                            examples: titleItem.examples?.map((example, index) => ({
                                ...example,
                                translations: example,
                                metadata: {
                                    difficulty: 1,
                                    category: 'general',
                                    notes: ''
                                },
                                id: `auto-${index}`
                            })) || []
                        })) || [],
                        metadata: {
                            topic: topicData.topic,
                            description: '',
                            languageCount: 4,
                            exampleCount: topicData.titles?.reduce((count, title) => count + (title.examples?.length || 0), 0) || 0,
                            difficulty: 'beginner',
                            version: '1.0'
                        }
                    };
                }
            },

            clearCache() {
                this.cache.clear();
            }
        };

        // ========== EXAMPLE RENDERING ==========
        const ExampleRenderer = {
            display: null,

            init(displayElement) {
                this.display = displayElement;
            },

            /** -------------------------------------------------------------
             *  Highlight a single word (by its zero‚Äëbased index) in the
             *  rendered example.  The renderer already knows how each span
             *  stores its word index in `data-index`, so we can locate it
             *  quickly, clear any previous highlight, and apply a theme‚Äëaware
             *  background colour.
             *  ------------------------------------------------------------- */
            highlightWord(index) {
                // First clear any existing highlights
                this.clearHighlights();

                // Find the span that represents the word at `index`
                const span = this.display.querySelector(`[data-index="${index}"]`);
                if (!span) return;

                const themeCls = document.body.dataset.theme === 'dark' ? 'highlight-dark' : 'highlight-light';
                span.classList.add(themeCls);
                span.style.background = document.body.dataset.theme === 'dark' ? 'orange' : 'yellow';
            },

            /** -------------------------------------------------------------
             *  Render an example ‚Äì accepts either the *new* array format
             *  or the original object that contains a `translations` map.
             *  In both cases we first normalise the data to an array of
             *  word‚Äëobjects, then render it.
             *  ------------------------------------------------------------- */
            render(example) {
                if (!this.display) return;

                // -----------------------------------------------------------------
                // 1Ô∏è‚É£  Normalise the payload ‚Äì always end up with an array
                // -----------------------------------------------------------------
                let wordsArray;
                if (!example) {
                    this.display.textContent = 'No example content available.';
                    return;
                }

                if (Array.isArray(example)) {
                    // Already in the final shape
                    wordsArray = example;
                } else if (example.translations && typeof example.translations === 'object') {
                    // New JSON shape ‚Äì convert the translations map to an array
                    wordsArray = this._flattenTranslations(example.translations);
                } else {
                    console.error('ExampleRenderer.render: unsupported example format', example);
                    this.display.textContent = 'Invalid example format.';
                    return;
                }

                if (wordsArray.length === 0) {
                    this.display.textContent = 'No example content available.';
                    return;
                }

                // -----------------------------------------------------------------
                // 2Ô∏è‚É£  Build the DOM fragment
                // -----------------------------------------------------------------
                const fragment = document.createDocumentFragment();

                wordsArray.forEach((word, idx) => {
                    // Newline handling ‚Äì a word that is just "\n" (or empty) becomes a <br>
                    if (this._isNewline(word)) {
                        fragment.appendChild(document.createElement('br'));
                        return;
                    }

                    const pairDiv = document.createElement('div');
                    pairDiv.className = 'word-pair performance-optimized';
                    pairDiv.dataset.index = idx;

                    // Render each **display‚Äëenabled** language
                    LanguageManager.getDisplayLanguages().forEach(lang => {
                        const txt = word[lang.code];
                        if (!txt) return;

                        const span = document.createElement('span');
                        span.textContent = txt;
                        span.lang = lang.code;
                        span.dataset.index = idx;
                        span.dataset.language = lang.code;
                        span.tabIndex = 0;
                        span.setAttribute('role', 'button');
                        span.setAttribute('aria-label', `Speak ${lang.name}: ${txt}`);

                        // Styling hooks
                        span.classList.add(`language-font-${lang.code}`);
                        if (lang.rtl) span.setAttribute('dir', 'rtl');
                        if (lang.code === 'th-TH') span.classList.add('thai-font');

                        // Click ‚Üí speak (only if the language is enabled for speaking)
                        span.onclick = () => {
                            if (Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak)) {
                                PlaybackController.playWord(txt, lang.code, span, idx);
                            }
                        };
                        span.onkeydown = e => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                span.click();
                            }
                        };

                        pairDiv.appendChild(span);
                    });

                    // Only add the pair if at least one language was rendered
                    if (pairDiv.children.length) fragment.appendChild(pairDiv);
                });

                this.display.innerHTML = '';
                this.display.appendChild(fragment);
                this.applyLanguageStyling();
            },

            /** -------------------------------------------------------------
             *  Convert the `translations` map (the format used in greetings.json)
             *  into the uniform array of word‚Äëobjects that the rest of the app
             *  expects.
             *
             *  Input:
             *    {
             *      "th-TH": ["‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ","‡∏Ñ‡∏£‡∏±‡∏ö"],
             *      "en-US": ["Hello","sir"],
             *      ‚Ä¶
             *    }
             *
             *  Output:
             *    [
             *      { "th-TH":"‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ", "en-US":"Hello", ‚Ä¶ },
             *      { "th-TH":"‡∏Ñ‡∏£‡∏±‡∏ö",   "en-US":"sir",   ‚Ä¶ }
             *    ]
             *  ------------------------------------------------------------- */
            _flattenTranslations(translations) {
                if (!translations || typeof translations !== 'object') return [];

                const langs = Object.keys(translations);
                // Guard against an empty translations object
                if (langs.length === 0) return [];

                const maxLen = Math.max(...langs.map(l => {
                    const arr = translations[l];
                    return Array.isArray(arr) ? arr.length : 1;
                }));

                const words = [];
                for (let i = 0; i < maxLen; i++) {   // ‚úÖ fixed i++
                    const word = {};
                    langs.forEach(l => {
                        const arr = translations[l];
                        word[l] = (Array.isArray(arr) ? arr[i] : arr) ?? '';
                    });
                    words.push(word);
                }
                return words;
            },

            _isNewline(word) {
                // A word is a newline when *all* displayed languages are empty or "\n"
                return LanguageManager.getDisplayLanguages().every(lang => {
                    const txt = word[lang.code];
                    return txt === '\n' || (txt && txt.trim() === '');
                });
            },

            applyLanguageStyling() {
                // Apply RTL and font styling to all language elements
                AppConfig.availableLanguages.forEach(language => {
                    const elements = this.display.querySelectorAll(`[lang="${language.code}"]`);
                    elements.forEach(el => {
                        el.classList.add(`language-font-${language.code}`);
                        if (language.rtl) {
                            el.setAttribute('dir', 'rtl');
                        }
                    });
                });
            },

            clearHighlights() {
                if (!this.display) return;
                // Clear highlights from spans instead of whole word‚Äëpairs
                this.display.querySelectorAll('.word-pair span[lang]').forEach(span => {
                    span.classList.remove('highlight-light', 'highlight-dark');
                    span.style.background = '';
                });
            }
        };

        /* -------------------------------------------------------------
           PlaybackController ‚Äì handles Play / Pause / Restart and the
           word‚Äëby‚Äëword, language‚Äëby‚Äëlanguage speech flow.
           ------------------------------------------------------------- */
        const PlaybackController = {
            /* -----------------------------------------------------------------
               State used by the controller
               ----------------------------------------------------------------- */
            currentTimeout: null,          // timeout handle for the inter‚Äëword delay
            currentSentence: [],          // array of word‚Äëobjects that will be spoken
            isPlaying: false,             // true while the example is running
            isPaused: false,              // true while the user has hit ‚ÄúPause‚Äù
            currentWordIndex: 0,          // index inside currentSentence
            currentLanguageIndex: 0,      // index inside the list of speak‚Äëlanguages

            /* -----------------------------------------------------------------
               Public entry point ‚Äì called when the user clicks the Play button
               ----------------------------------------------------------------- */
            async playExample() {
                // If we are already playing ‚Üí pause
                if (this.isPlaying && !this.isPaused) {
                    this.pauseExample();
                    return;
                }

                // If we are paused ‚Üí resume
                if (this.isPaused) {
                    this.resumeExample();
                    return;
                }

                // -----------------------------------------------------------------
                // Fresh start ‚Äì build the sentence that will be spoken
                // -----------------------------------------------------------------
                const example = AppState.getCurrentExample();
                if (!example || (Array.isArray(example) && example.length === 0)) return;

                this.isPlaying = true;
                this.isPaused = false;
                this.currentSentence = this.prepareSentenceForPlayback(example);
                this.currentWordIndex = 0;
                this.currentLanguageIndex = 0;
                AppState.currentWordIndex = 0;

                ScreenReader.announce('Playback started');
                // NOTE: we do **not** highlight the whole pair here.
                // Each language will be highlighted right before it is spoken.
                await this.playbackLoop();
            },

            /* -----------------------------------------------------------------
               Pause ‚Äì stops the timer and cancels any ongoing utterance
               ----------------------------------------------------------------- */
            pauseExample() {
                this.isPaused = true;
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                TTSManager.cancel();                 // stops the current utterance
                ScreenReader.announce('Playback paused');
            },

            /* -----------------------------------------------------------------
               Resume ‚Äì continues from where we left off
               ----------------------------------------------------------------- */
            resumeExample() {
                if (!this.isPaused) return;          // nothing to do
                this.isPaused = false;
                this.isPlaying = true;
                ScreenReader.announce('Playback resumed');
                this.playbackLoop();                  // continue the loop
            },

            /* -----------------------------------------------------------------
               Restart ‚Äì clears everything and starts from the first word
               ----------------------------------------------------------------- */
            restartExample() {
                this.stopPlayback();
                ExampleRenderer.clearHighlights();
                this.currentWordIndex = 0;
                this.currentLanguageIndex = 0;
                AppState.currentWordIndex = 0;
                this.playExample();
            },

            /* -----------------------------------------------------------------
               Stop ‚Äì used by Restart and by the internal clean‚Äëup logic
               ----------------------------------------------------------------- */
            stopPlayback() {
                this.isPlaying = false;
                this.isPaused = false;
                this.currentLanguageIndex = 0;
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                TTSManager.cancel();
            },

            /* -----------------------------------------------------------------
               Core loop ‚Äì walks through the sentence word‚Äëby‚Äëword
               ----------------------------------------------------------------- */
            async playbackLoop() {
                // -------------------------------------------------------------
                // 0Ô∏è‚É£  ALWAYS reset the pause flag at the start of each loop.
                // -------------------------------------------------------------
                this.isPaused = false;

                // -------------------------------------------------------------
                // 1Ô∏è‚É£  Debug ‚Äì show that the loop has (re)started
                // -------------------------------------------------------------
                console.debug(`playbackLoop ‚Äì word index ${this.currentWordIndex} (isPlaying=${this.isPlaying}, isPaused=${this.isPaused})`);

                // -------------------------------------------------------------
                // 2Ô∏è‚É£  Playback stopped ‚Üí clean up and exit
                // -------------------------------------------------------------
                if (!this.isPlaying) {
                    this.cleanupPlayback();
                    return;
                }

                // -------------------------------------------------------------
                // 3Ô∏è‚É£  Paused ‚Üí poll every 200‚ÄØms (only when the user explicitly
                //     clicks the Pause button; we already cleared accidental pauses)
                // -------------------------------------------------------------
                if (this.isPaused) {
                    setTimeout(() => this.playbackLoop(), 200);
                    return;
                }

                // -------------------------------------------------------------
                // 4Ô∏è‚É£  End of sentence ‚Üí finish
                // -------------------------------------------------------------
                if (this.currentWordIndex >= this.currentSentence.length) {
                    this.completePlayback();
                    return;
                }

                // -------------------------------------------------------------
                // 5Ô∏è‚É£  **REMOVED** ‚Äì we no longer highlight the whole word‚Äëpair here.
                //     Per‚Äëlanguage highlighting is handled inside `playWord`,
                //     which clears previous highlights and then highlights the
                //     exact span for the language being spoken.
                // -------------------------------------------------------------

                // -------------------------------------------------------------
                // 6Ô∏è‚É£  Speak the current word in **each selected language**
                // -------------------------------------------------------------
                const word = this.currentSentence[this.currentWordIndex];
                await this.speakAllLanguagesForWord(word);

                // -------------------------------------------------------------
                // 7Ô∏è‚É£  Advance to the next word
                // -------------------------------------------------------------
                this.currentWordIndex++;
                this.currentLanguageIndex = 0;               // reset language counter
                AppState.currentWordIndex = this.currentWordIndex;

                // -------------------------------------------------------------
                // 8Ô∏è‚É£  Wait the user‚Äëdefined delay, then recurse
                // -------------------------------------------------------------
                const delay = this.getPlaybackDelay();       // ms (minimum 500‚ÄØms)

                // Use an await‚Äëbased delay (no stored timeout ID needed)
                await new Promise(r => setTimeout(r, delay));
                await this.playbackLoop();   // recurse for the next word
            },


            /* -----------------------------------------------------------------
               Speak every language that the user has ticked ‚ÄúSpeak‚Äù.
               For each language we **highlight the exact span** that is being
               spoken, then call the low‚Äëlevel TTS routine.
               The loop never aborts on a missing voice ‚Äì it simply continues
               to the next language (or next word) after announcing the problem.
               ----------------------------------------------------------------- */
            async speakAllLanguagesForWord(word) {
                // 1Ô∏è‚É£  Get the list of languages that should be spoken.
                //      This method returns the union of ‚ÄúSpeak‚Äù and ‚ÄúDisplay‚Äù
                //      languages, so every displayed language will be processed.
                const speakLanguages = LanguageManager.getSpeakLanguages();

                // 2Ô∏è‚É£  Defensive guard ‚Äì should never be empty because we fall back,
                //      but keep the warning just in case.
                if (speakLanguages.length === 0) {
                    console.warn('No Speak languages selected ‚Äì nothing will be spoken.');
                    return;
                }

                // 3Ô∏è‚É£  Log the languages we are about to process (helps debugging)
                console.debug('Speaking word with languages:',
                    speakLanguages.map(l => l.code));

                // 4Ô∏è‚É£  Loop over each language for the current word.
                for (let i = 0; i < speakLanguages.length; i++) {
                    const language = speakLanguages[i];

                    // ---------------------------------------------------------
                    // Grab the text for this language.
                    // ---------------------------------------------------------
                    const text = word[language.code];
                    if (!text || text === "\n" || text.trim() === '') {
                        console.debug(`No text for language "${language.code}" ‚Äì skipping`);
                        continue; // Nothing to speak for this language
                    }

                    // ---------------------------------------------------------
                    // Find the exact <span> that represents this word‚Äëlanguage pair.
                    // ---------------------------------------------------------
                    const span = document.querySelector(
                        `.word-pair span[data-index="${this.currentWordIndex}"][data-language="${language.code}"]`
                    );

                    if (!span) {
                        // This should not happen if the language is also displayed,
                        // but we guard against it so the loop never gets stuck.
                        console.warn(`Span not found for language "${language.code}" at word index ${this.currentWordIndex}`);
                        continue; // Skip to the next language
                    }

                    // ---------------------------------------------------------
                    // Highlight the span **before** speaking.
                    // ---------------------------------------------------------
                    const themeCls = document.body.dataset.theme === 'dark' ? 'highlight-dark' : 'highlight-light';
                    span.classList.add(themeCls);
                    span.style.background = document.body.dataset.theme === 'dark' ? 'orange' : 'yellow';

                    // ---------------------------------------------------------
                    // Call playWord ‚Äì it will invoke speakWord (which handles
                    // missing‚Äëvoice cases) and will clear the highlight when
                    // the utterance finishes.
                    // ---------------------------------------------------------
                    console.debug(`Calling playWord for language "${language.code}"`);
                    await this.playWord(text, language.code, span, this.currentWordIndex);
                    console.debug(`Finished playWord for language "${language.code}"`);

                    // ---------------------------------------------------------
                    // Small pause between languages so the speech doesn‚Äôt sound rushed.
                    // ---------------------------------------------------------
                    if (i < speakLanguages.length - 1) {
                        await new Promise(r => setTimeout(r, 200));
                    }
                }

                // 5Ô∏è‚É£  All languages for this word have been processed ‚Äì reset the
                //     language index so the next word starts from the first language.
                this.currentLanguageIndex = 0;
            },

            /* -------------------------------------------------------------
               Build a uniform sentence array from the example data.
               The only supported format is:
               {
                   translations: {
                       "th-TH": ["‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ","‡∏Ñ‡∏£‡∏±‡∏ö"],
                       "en-US": ["Hello","sir"],
                       ‚Ä¶
                   }
               }
               ------------------------------------------------------------- */
            prepareSentenceForPlayback(example) {
                if (!example) return [];

                // New format ‚Äì already an array of word objects (unlikely for our data)
                if (Array.isArray(example)) {
                    return example;
                }

                // New format with a `translations` map ‚Äì this is the only format we support now
                if (example.translations && typeof example.translations === 'object') {
                    return this._flattenTranslations(example.translations);
                }

                // Anything else is a programmer error ‚Äì surface it clearly
                console.error('Unsupported example format ‚Äì expected a `translations` object:', example);
                return [];
            },

            /**
             * Convert the translations map into an array of word‚Äëobjects.
             *
             * Input:
             *   {
             *     "th-TH": ["‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ","‡∏Ñ‡∏£‡∏±‡∏ö"],
             *     "en-US": ["Hello","sir"],
             *     ‚Ä¶
             *   }
             *
             * Output:
             *   [
             *     { "th-TH":"‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ", "en-US":"Hello", ‚Ä¶ },
             *     { "th-TH":"‡∏Ñ‡∏£‡∏±‡∏ö",   "en-US":"sir",   ‚Ä¶ }
             *   ]
             */
            _flattenTranslations(translations) {
                if (!translations || typeof translations !== 'object') return [];

                const langs = Object.keys(translations);
                // Guard against an empty translations object
                if (langs.length === 0) return [];

                const maxLen = Math.max(...langs.map(l => {
                    const arr = translations[l];
                    return Array.isArray(arr) ? arr.length : 1;
                }));

                const words = [];
                for (let i = 0; i < maxLen; i++) {   // ‚úÖ fixed i++
                    const word = {};
                    langs.forEach(l => {
                        const arr = translations[l];
                        word[l] = (Array.isArray(arr) ? arr[i] : arr) ?? '';
                    });
                    words.push(word);
                }
                return words;
            },

            /* -----------------------------------------------------------------
               Helper: map the internal word index to the index that the UI uses.
               (At the moment they are the same, but keeping the indirection
               makes future tweaks easier.)
               ----------------------------------------------------------------- */
            getDisplayIndexForWord(wordIndex) {
                return wordIndex;
            },

            /* -----------------------------------------------------------------
               User‚Äëconfigurable delay (seconds ‚Üí milliseconds, minimum 500‚ÄØms)
               ----------------------------------------------------------------- */
            getPlaybackDelay() {
                const d = parseFloat(Storage.load(
                    CONSTANTS.STORAGE_KEYS.PLAYBACK_DELAY,
                    CONSTANTS.DEFAULT_VALUES.PLAYBACK_DELAY
                ));
                return Math.max(500, d * 1000);
            },

            /* -----------------------------------------------------------------
               Low‚Äëlevel wrapper around the Web Speech API.
               Returns a promise that resolves **true** when the utterance ends
               (or when it times‚Äëout) and **false** only on genuine TTS errors.
               If no matching voice is found, the promise resolves **true** after
               announcing the missing voice, allowing playback to continue.
               ----------------------------------------------------------------- */
            speakWord(text, lang) {
                return new Promise(async resolve => {
                    // 1Ô∏è‚É£  Guard ‚Äì ignore empty strings or pure new‚Äëlines
                    if (!text || text === "\n" || text.trim() === '') {
                        resolve(true);
                        return;
                    }

                    // 2Ô∏è‚É£  Verify that the browser actually supports Speech Synthesis
                    if (!('speechSynthesis' in window) ||
                        typeof SpeechSynthesisUtterance === 'undefined') {
                        console.warn('Speech synthesis not supported in this browser');
                        ScreenReader.announce('Speech synthesis is not supported in this browser.');
                        resolve(false);
                        return;
                    }

                    // 3Ô∏è‚É£  Make sure the voice list is populated.
                    let allVoices = speechSynthesis.getVoices();

                    if (allVoices.length === 0) {
                        console.debug('Voice list empty ‚Äì waiting for voiceschanged event...');
                        await new Promise(r => {
                            const handler = () => {
                                speechSynthesis.removeEventListener('voiceschanged', handler);
                                r();
                            };
                            speechSynthesis.addEventListener('voiceschanged', handler);
                            // Fallback timeout in case the event never fires
                            setTimeout(r, 500);
                        });
                        allVoices = speechSynthesis.getVoices();
                    }

                    // 4Ô∏è‚É£  Filter for voices that actually support the requested language
                    const matchingVoices = allVoices.filter(v =>
                        v.lang && v.lang.toLowerCase().startsWith(lang.toLowerCase())
                    );

                    console.debug(`Found ${matchingVoices.length} voice(s) for language "${lang}"`);

                    // 5Ô∏è‚É£  No matching voice?  Announce the problem **but do not abort**.
                    if (matchingVoices.length === 0) {
                        const msg = `No Text‚Äëto‚ÄëSpeech voice found for language "${lang}". ` +
                            `Open the Help & Support panel and click ‚ÄúTest TTS Setup & Language Support‚Äù ` +
                            `to see how to install the required language pack.`;
                        console.warn(msg);
                        ScreenReader.announce(msg);

                        // Optional on‚Äëscreen banner (helps sighted users)
                        const banner = document.createElement('div');
                        banner.className = 'missing-voice-banner';
                        banner.textContent = msg;
                        banner.style.cssText = `
    position:fixed; top:0; left:0; width:100%;
    background:#ffeb3b; color:#000;
    padding:0.6em; text-align:center;
    font-weight:bold; z-index:1000;
`;
                        document.body.appendChild(banner);
                        setTimeout(() => banner.remove(), 8000);

                        // Resolve **true** so playback continues to the next language/word
                        resolve(true);
                        return;
                    }

                    // 6Ô∏è‚É£  Pick the first matching voice (good enough for our demo)
                    const chosenVoice = matchingVoices[0];
                    console.debug(`Using voice "${chosenVoice.name}" (lang=${chosenVoice.lang})`);

                    // 7Ô∏è‚É£  Build the utterance
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = lang;
                    utterance.voice = chosenVoice;
                    utterance.volume = 0.8;
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;

                    // 8Ô∏è‚É£  Resolve the promise when the utterance finishes or errors
                    let finished = false;
                    const finish = ok => {
                        if (finished) return;
                        finished = true;
                        clearTimeout(timeoutId);
                        resolve(ok);
                    };

                    utterance.onend = () => finish(true);
                    utterance.onerror = (e) => {
                        console.error('Speech synthesis error:', e.error);
                        ScreenReader.announce(`Speech error: ${e.error}`);
                        finish(false);
                    };

                    // 9Ô∏è‚É£  Safety net ‚Äì timeout after 5‚ÄØseconds
                    const timeoutId = setTimeout(() => {
                        console.warn(`Speech synthesis timeout for language "${lang}"`);
                        ScreenReader.announce(`Speech timed out for language ${lang}`);
                        finish(false);
                    }, 5000);

                    // üîü  Finally, speak!
                    speechSynthesis.speak(utterance);
                });
            },

            /* -----------------------------------------------------------------
               Cleanup helpers ‚Äì called when playback finishes or is aborted
               ----------------------------------------------------------------- */
            cleanupPlayback() {
                this.isPlaying = false;
                this.isPaused = false;
                this.currentWordIndex = 0;
                this.currentLanguageIndex = 0;
                AppState.currentWordIndex = 0;
                ExampleRenderer.clearHighlights();
            },

            completePlayback() {
                this.cleanupPlayback();
                ScreenReader.announce('Playback completed');
            },

            /* -----------------------------------------------------------------
               Click‚Äëhandler for a single word (used by the UI)
               ----------------------------------------------------------------- */
            async playWord(text, lang, element, index) {
                if (!text || text.trim() === '') return;

                // Clear any previous per‚Äëspan highlight first
                ExampleRenderer.clearHighlights();

                // Highlight the span that is about to be spoken
                if (element) {
                    const themeCls = document.body.dataset.theme === 'dark' ? 'highlight-dark' : 'highlight-light';
                    element.classList.add(themeCls);
                    element.style.background = document.body.dataset.theme === 'dark' ? 'orange' : 'yellow';
                }

                // Actually speak the word
                await this.speakWord(text, lang);
                ScreenReader.announce(`Speaking: ${text}`);
            }
        };


        /* -------------------------------------------------------------
           END OF PATCH ‚Äì the rest of the file stays unchanged
           ------------------------------------------------------------- */
        const QuizSystem = {
            data: [],
            currentQuestion: 0,
            score: 0,
            attempts: 0,
            incorrectOnly: false,

            buildFromExample(example) {
                if (!example) {
                    console.warn('No example data provided for quiz');
                    this.data = [];
                    this.render();
                    return;
                }

                try {
                    // Convert example data to quiz format - handle both array and object formats
                    this.data = this.convertExampleToQuestions(example);
                    this.currentQuestion = 0;
                    this.score = 0;
                    this.attempts = 0;
                    this.render();
                } catch (error) {
                    console.error('Error building quiz from example:', error);
                    this.data = [];
                    this.render();
                }
            },

            convertExampleToQuestions(example) {
                const questions = [];
                const questionLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.QUESTION_LANG,
                    CONSTANTS.DEFAULT_VALUES.QUESTION_LANG
                );
                const answerLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.ANSWER_LANG,
                    CONSTANTS.DEFAULT_VALUES.ANSWER_LANG
                );

                // ---------------------------------------------------------
                // 1Ô∏è‚É£  Normalise the example into an array of word‚Äëobjects
                // ---------------------------------------------------------
                let words = [];

                if (Array.isArray(example)) {
                    // New format ‚Äì already an array of word objects
                    words = example;
                } else if (example.translations && typeof example.translations === 'object') {
                    // Old format ‚Äì reuse the flatten helper that lives on PlaybackController
                    words = PlaybackController._flattenTranslations(example.translations);
                } else if (typeof example === 'object') {
                    // Single word object ‚Äì wrap it in an array so the rest of the code works uniformly
                    words = [example];
                } else {
                    console.warn('Unexpected example format for quiz:', example);
                    return [];
                }

                // ---------------------------------------------------------
                // 2Ô∏è‚É£  Keep only the entries that have BOTH a question
                //     AND an answer in the selected languages
                // ---------------------------------------------------------
                const validWords = words.filter(word => {
                    if (!word || typeof word !== 'object') return false;

                    const hasQuestion = word[questionLang] && word[questionLang].trim() !== '';
                    const hasAnswer = word[answerLang] && word[answerLang].trim() !== '';
                    return hasQuestion && hasAnswer;
                });

                if (validWords.length === 0) {
                    console.warn('No valid words found for quiz in current languages');
                    console.log('All words:', words);
                    console.log('Question language:', questionLang, 'Answer language:', answerLang);
                    return [];
                }

                // ---------------------------------------------------------
                // 3Ô∏è‚É£  Build a question object for each valid word
                // ---------------------------------------------------------
                validWords.forEach((word, idx) => {
                    const question = {
                        id: `q-${idx}`,
                        [questionLang]: word[questionLang],
                        [answerLang]: word[answerLang],
                        translations: word,
                        attempted: false,
                        correct: false,
                        options: this.generateOptions(validWords, idx, answerLang)
                    };
                    questions.push(question);
                });

                console.log(`Created ${questions.length} quiz questions`);
                return questions;
            },

            _makeOptions(pool, correctIdx, answerLang) {
                const correct = pool[correctIdx][answerLang];
                const others = pool.filter((_, i) => i !== correctIdx);
                const shuffled = others.sort(() => 0.5 - Math.random()).slice(0, 3);
                const opts = [correct, ...shuffled.map(w => w[answerLang])];
                return opts.sort(() => 0.5 - Math.random());
            },

            // Helper method to convert old translation format to word array format
            flattenTranslationsToWords(translations) {
                const languages = Object.keys(translations);
                const maxLength = Math.max(...languages.map(lang => {
                    const content = translations[lang];
                    return Array.isArray(content) ? content.length : 1;
                }));

                const words = [];
                for (let i = 0; i < maxLength; i++) {
                    const word = {};
                    languages.forEach(lang => {
                        const content = translations[lang];
                        if (Array.isArray(content)) {
                            word[lang] = content[i] || '';
                        } else {
                            // Handle single string by splitting into words or using entire string
                            word[lang] = i === 0 ? content : '';
                        }
                    });
                    words.push(word);
                }
                return words;
            },

            generateOptions(words, correctIndex, answerLang) {
                const correctAnswer = words[correctIndex][answerLang];
                const options = [correctAnswer];

                // Get 3 random incorrect options
                const otherWords = words.filter((_, index) => index !== correctIndex);
                const shuffled = [...otherWords].sort(() => 0.5 - Math.random());
                const incorrectOptions = shuffled.slice(0, 3).map(word => word[answerLang]);

                options.push(...incorrectOptions);

                // Shuffle all options
                return options.sort(() => 0.5 - Math.random());
            },

            render() {
                const quizContainer = document.getElementById('quiz');
                if (!quizContainer) return;

                const filteredQuestions = this.getFilteredQuestions();

                if (filteredQuestions.length === 0) {
                    if (this.incorrectOnly) {
                        this.showNoIncorrectMessage(quizContainer);
                    } else {
                        this.showCompletionMessage(quizContainer);
                    }
                    return;
                }

                const currentQ = filteredQuestions[this.currentQuestion];
                const questionLang = Storage.load(CONSTANTS.STORAGE_KEYS.QUESTION_LANG, CONSTANTS.DEFAULT_VALUES.QUESTION_LANG);
                const answerLang = Storage.load(CONSTANTS.STORAGE_KEYS.ANSWER_LANG, CONSTANTS.DEFAULT_VALUES.ANSWER_LANG);

                const questionText = currentQ[questionLang] || currentQ.translations?.[questionLang] || 'No question text available';
                const options = currentQ.options || [];

                quizContainer.innerHTML = `
            <div class="quiz-heading">Translate this word:</div>
            <div class="quiz-question" lang="${questionLang}">${this.escapeHTML(questionText)}</div>
            <div class="quiz-options">
                ${options.map((option, index) => `
                    <div class="quiz-option ${currentQ.attempted ? (option === currentQ[answerLang] ? 'correct' : 'incorrect') : ''}" 
                         data-option="${this.escapeHTML(option)}"
                         onclick="QuizSystem.handleAnswer(this, '${this.escapeHTML(option)}', ${this.currentQuestion}, '${answerLang}')">
                        ${this.escapeHTML(option)}
                    </div>
                `).join('')}
            </div>
            `;

                // Update progress indicator
                const progressText = `Question ${this.currentQuestion + 1} of ${filteredQuestions.length}`;
                ScreenReader.announce(progressText);
            },

            escapeHTML(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            getFilteredQuestions() {
                if (this.incorrectOnly) {
                    return this.data.filter(q => q.attempted && !q.correct);
                }
                return this.data.filter(q => !q.attempted || !this.incorrectOnly);
            },

            showNoIncorrectMessage(container) {
                container.innerHTML = `
            <div style="text-align: center; padding: 2em; color: var(--text-light);">
                <p>üéâ No incorrect answers! Great job!</p>
                <p>Uncheck "Incorrect Only" to practice all questions again.</p>
            </div>
        `;
            },

            showCompletionMessage(container) {
                container.innerHTML = `
            <div style="text-align: center; padding: 2em; color: var(--text-light);">
                <p>‚úÖ Quiz completed!</p>
                <p>Score: ${this.score}/${this.attempts}</p>
                <p>Click "Retry Quiz" to practice again.</p>
            </div>
        `;
            },

            handleAnswer(optionEl, selectedOption, questionIndex, answerLang) {
                const filteredQuestions = this.getFilteredQuestions();
                const question = filteredQuestions[questionIndex];

                if (!question || question.attempted) return;

                const correctAnswer = question[answerLang] || question.translations?.[answerLang];
                const isCorrect = selectedOption === correctAnswer;

                question.attempted = true;
                question.correct = isCorrect;
                this.attempts++;

                if (isCorrect) {
                    optionEl.classList.add('correct');
                    this.score++;
                    ScreenReader.announce(`Correct! ${selectedOption}`);
                } else {
                    optionEl.classList.add('incorrect');
                    // Highlight correct answer
                    const options = document.querySelectorAll('.quiz-option');
                    options.forEach(opt => {
                        if (opt.textContent === correctAnswer) {
                            opt.classList.add('correct');
                        }
                    });
                    ScreenReader.announce(`Incorrect. The correct answer is ${correctAnswer}`);
                }

                // Update score display
                const scoreElement = document.getElementById("score");
                if (scoreElement) {
                    scoreElement.textContent = `Score: ${this.score}/${this.attempts}`;
                }

                // Auto-advance after delay
                setTimeout(() => {
                    this.nextQuestion();
                }, 2000);
            },

            nextQuestion() {
                const filteredQuestions = this.getFilteredQuestions();
                if (filteredQuestions.length === 0) {
                    this.render();
                    return;
                }

                if (this.currentQuestion < filteredQuestions.length - 1) {
                    this.currentQuestion++;
                } else {
                    this.currentQuestion = 0;
                }
                this.render();
            },

            previousQuestion() {
                const filteredQuestions = this.getFilteredQuestions();
                if (filteredQuestions.length === 0) {
                    this.render();
                    return;
                }

                if (this.currentQuestion > 0) {
                    this.currentQuestion--;
                } else {
                    this.currentQuestion = filteredQuestions.length - 1;
                }
                this.render();
            },

            retry() {
                this.data.forEach(q => {
                    q.attempted = false;
                    q.correct = false;
                });
                this.currentQuestion = 0;
                this.score = 0;
                this.attempts = 0;
                this.render();

                const scoreElement = document.getElementById("score");
                if (scoreElement) {
                    scoreElement.textContent = `Score: ${this.score}/${this.attempts}`;
                }

                ScreenReader.announce('Quiz reset. Starting over.');
            },

            toggleIncorrectOnly(showIncorrectOnly) {
                this.incorrectOnly = showIncorrectOnly;
                this.currentQuestion = 0;
                this.render();
                ScreenReader.announce(showIncorrectOnly ?
                    'Showing only incorrect questions' :
                    'Showing all questions'
                );
            },

            refreshQuiz() {
                // Rebuild quiz when languages change
                const currentExample = AppState.getCurrentExample();
                if (currentExample && currentExample.length > 0) {
                    this.buildFromExample(currentExample);
                }
            }
        };

        /* -------------------------------------------------------------
           NavigationController ‚Äì handles topic / title / example selection
           and the forward / backward arrows.
           ------------------------------------------------------------- */
        const NavigationController = {
            topicSelect: null,
            titleSelect: null,
            exampleSelect: null,

            // -----------------------------------------------------------------
            // Simple lock to prevent the navigation functions from running
            // twice at the same time (e.g., button click + ArrowRight key).
            // -----------------------------------------------------------------
            navLock: false,

            init(topicSelect, titleSelect, exampleSelect) {
                this.topicSelect = topicSelect;
                this.titleSelect = titleSelect;
                this.exampleSelect = exampleSelect;

                if (topicSelect) {
                    topicSelect.addEventListener('change', (e) => this.handleTopicChange(e.target.value));
                }
                if (titleSelect) {
                    titleSelect.addEventListener('change', (e) => this.handleTitleChange(+e.target.value));
                }
                // **No change listener for exampleSelect** ‚Äì we control it manually.
            },

            async handleTopicChange(topicFilename) {
                if (!topicFilename) return;

                try {
                    Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC, topicFilename);
                    await AppController.loadTopic(topicFilename);
                    ScreenReader.announce(`Topic changed to ${topicFilename}`);
                } catch (error) {
                    console.error('Error changing topic:', error);
                    ScreenReader.announce(`Error changing topic: ${error.message}`);
                }
            },

            handleTitleChange(titleIndex) {
                AppState.currentTitle = titleIndex;
                AppController.populateExamples();

                // After repopulating the example list, load the first example of the new title
                AppState.currentExample = 0;
                AppController.loadExample();

                // Sync the UI <select> to the first example (index 0)
                if (this.exampleSelect) {
                    this.exampleSelect.selectedIndex = 0;
                }

                ScreenReader.announce(`Title changed to ${titleIndex + 1}`);
            },

            /** -------------------------------------------------------------
             *  Move to the **next** example.
             *  ‚Ä¢ Updates AppState only once.
             *  ‚Ä¢ Loads the new example immediately.
             *  ‚Ä¢ Afterwards synchronises the <select> UI (without firing a change event).
             *  ------------------------------------------------------------- */
            nextExample() {
                if (this.navLock) return;               // Prevent re‚Äëentry
                this.navLock = true;

                const currentTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                const maxExamples = currentTitle?.examples?.length || 0;

                // ---------------------------------------------------------
                // CASE 1 ‚Äì Still inside the current title
                // ---------------------------------------------------------
                if (AppState.currentExample < maxExamples - 1) {
                    // ONE increment ONLY
                    AppState.currentExample++;

                    // Load the new example first
                    AppController.loadExample();

                    // THEN update the <select> UI (no change event is fired)
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = AppState.currentExample;
                    }

                    // Release lock after the UI has settled
                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 2 ‚Äì At the last example of the current title ‚Üí go to next title
                // ---------------------------------------------------------
                const maxTitles = AppState.currentTopic?.titles?.length || 0;
                if (AppState.currentTitle < maxTitles - 1) {
                    // Move to next title and start at its first example
                    AppState.currentTitle++;
                    AppState.currentExample = 0;

                    // Update title <select>
                    if (this.titleSelect) {
                        this.titleSelect.selectedIndex = AppState.currentTitle;
                    }

                    // Re‚Äëpopulate examples for the new title and load the first one
                    AppController.populateExamples();
                    AppController.loadExample();

                    // Sync example <select> to the first example (index 0)
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = 0;
                    }

                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 3 ‚Äì Last title AND last example ‚Üí wrap to the very first
                // ---------------------------------------------------------
                AppState.currentTitle = 0;
                AppState.currentExample = 0;

                // Update title <select> to first title
                if (this.titleSelect) {
                    this.titleSelect.selectedIndex = 0;
                }

                // Re‚Äëpopulate examples for the first title and load its first example
                AppController.populateExamples();
                AppController.loadExample();

                // Sync example <select> to first example
                if (this.exampleSelect) {
                    this.exampleSelect.selectedIndex = 0;
                }

                setTimeout(() => { this.navLock = false; }, 0);
            },

            /** -------------------------------------------------------------
             *  Move to the **previous** example.
             *  Mirrors the logic of `nextExample` but in reverse.
             *  ------------------------------------------------------------- */
            previousExample() {
                if (this.navLock) return;               // Prevent re‚Äëentry
                this.navLock = true;

                // ---------------------------------------------------------
                // CASE 1 ‚Äì Still inside the current title (not the first example)
                // ---------------------------------------------------------
                if (AppState.currentExample > 0) {
                    // ONE decrement ONLY
                    AppState.currentExample--;

                    // Load the new example first
                    AppController.loadExample();

                    // THEN update the <select> UI (no change event is fired)
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = AppState.currentExample;
                    }

                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 2 ‚Äì At the first example of the current title ‚Üí go to previous title
                // ---------------------------------------------------------
                if (AppState.currentTitle > 0) {
                    // Move to previous title
                    AppState.currentTitle--;

                    const prevTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                    AppState.currentExample = (prevTitle?.examples?.length || 1) - 1; // last example of that title

                    // Update title <select>
                    if (this.titleSelect) {
                        this.titleSelect.selectedIndex = AppState.currentTitle;
                    }

                    // Re‚Äëpopulate examples for the new title and load the last example
                    AppController.populateExamples();
                    AppController.loadExample();

                    // Sync example <select> to the last example of the new title
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = AppState.currentExample;
                    }

                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 3 ‚Äì First title AND first example ‚Üí wrap to the very last
                // ---------------------------------------------------------
                const maxTitles = AppState.currentTopic?.titles?.length || 0;
                AppState.currentTitle = maxTitles - 1;        // last title
                const lastTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                AppState.currentExample = (lastTitle?.examples?.length || 1) - 1; // last example of last title

                // Update title <select> to last title
                if (this.titleSelect) {
                    this.titleSelect.selectedIndex = AppState.currentTitle;
                }

                // Re‚Äëpopulate examples for the last title and load its last example
                AppController.populateExamples();
                AppController.loadExample();

                // Sync example <select> to the last example
                if (this.exampleSelect) {
                    this.exampleSelect.selectedIndex = AppState.currentExample;
                }

                setTimeout(() => { this.navLock = false; }, 0);
            }
        };

        // ========== KEYBOARD SHORTCUT MANAGER ==========
        const KeyboardManager = {
            init() {
                document.addEventListener('keydown', this.handleKeydown.bind(this));
            },

            handleKeydown(event) {
                // Don't trigger shortcuts when user is typing in inputs
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch (event.key) {
                    case ' ':
                        event.preventDefault();
                        if (AppState.isPlaying) {
                            PlaybackController.pauseExample();
                        } else {
                            PlaybackController.playExample();
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        NavigationController.nextExample();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        NavigationController.previousExample();
                        break;
                    case 'r':
                    case 'R':
                        event.preventDefault();
                        PlaybackController.restartExample();
                        break;
                    case 'n':
                    case 'N':
                        event.preventDefault();
                        QuizSystem.nextQuestion();
                        break;
                    case 's':
                    case 'S':
                        event.preventDefault();
                        if (!document.getElementById('settingsThaiFont')) {
                            SettingsManager.show();
                        }
                        break;
                    case 'Escape':
                        if (document.getElementById('settingsThaiFont')) {
                            event.preventDefault();
                            SettingsManager.close();
                        }
                        break;
                }
            }
        };

        // ========== MAIN APPLICATION CONTROLLER ==========
        // ========== MAIN APPLICATION CONTROLLER ==========
        const AppController = {
            async initSPA() {
                // Initialize all managers and components
                ThemeManager.init();
                FontManager.init();
                TTSManager.initialize();
                KeyboardManager.init();

                // Initialize AppState
                AppState.initialize();

                // Load configuration
                await AppConfig.load();

                // Initialize language manager after config is loaded
                LanguageManager.init();

                // Initialize example renderer
                const exampleDisplay = document.getElementById('exampleDisplay');
                if (exampleDisplay) {
                    ExampleRenderer.init(exampleDisplay);
                }

                // Load topics and setup navigation
                await this.loadTopics();
                this.bindUIElements();

                // Load initial example
                this.loadExample();

                ScreenReader.announce('Application initialized successfully');
            },

            async init() {
                // Alternative initialization if needed
                await this.initSPA();
            },

            getMainHTML() {
                return `
            <div class="selection-header">Text To Speech</div>

            <!-- Progress Bar -->
            <div style="margin: 0.5em 0;">
                <div class="progress-bar">
                    <div id="progressBar" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>

            <details class="topic-options-details" id="topicOptionsDetails">
                <summary>Topic & Language Options</summary>
                <div class="topic-options-content">
                    <div id="topicSelectionControls" class="topic-selection-controls">
                        <label>Topic: <select id="topicSelect" aria-label="Select topic"></select></label>
                        <label>Title: <select id="titleSelect" aria-label="Select title"></select></label>
                        <label>Example: <select id="exampleSelect" aria-label="Select example"></select></label>
                    </div>

                    <div class="language-controls">
                        <details>
                            <summary style="font-weight: bold;">Language Options</summary>
                            <div class="language-controls-content">
                                <!-- Dynamic Language Grid -->
                                <div class="language-controls-grid">
                                    <div class="language-grid">
                                        <div class="language-grid-header">Language</div>
                                        <div class="language-grid-header">Display</div>
                                        <div class="language-grid-header">Speak</div>
                                        <!-- Language rows will be dynamically inserted here -->
                                    </div>
                                </div>

                                <!-- Playback Delay -->
                                <div class="language-delay-row">
                                    <span class="delay-label">Reading delay (secs)</span>
                                    <input type="number" id="playbackDelay" class="delay-input" value="0.5" min="0.5"
                                        max="5.0" step="1.0" aria-label="Playback delay in seconds">
                                </div>
                            </div>
                        </details>
                    </div>
                </div>
            </details>

            <section id="exampleSec">
                <div id="exampleDisplay" aria-live="polite"></div>
                <div id="exampleControls" class="controls">
                    <div class="example-controls-row">
                        <button id="playBtn" aria-label="Play example" class="touch-target">‚ñ∂Ô∏è</button>
                        <button id="pauseBtn" aria-label="Pause example" class="touch-target">‚è∏Ô∏è</button>
                        <button id="restartBtn" aria-label="Restart example" class="touch-target">‚èÆÔ∏è</button>
                        <div class="example-number-container">
                            <span class="example-number-label">Example</span>
                            <span id="currentExampleNumber" class="example-number">1</span>
                        </div>
                        <button id="prevExample" aria-label="Previous example" class="touch-target">‚¨ÖÔ∏è</button>
                        <button id="nextExample" aria-label="Next example" class="touch-target">‚û°Ô∏è</button>
                    </div>
                </div>
            </section>

            <section id="quizSec">
                <h3>Practice Quiz</h3>

                <div id="quiz" aria-live="polite"></div>
                <div id="quizControls">
                    <!-- Dynamic Language selection -->
                    <div class="quiz-row quiz-row-top">
                        <div class="lang-option">
                            <label>Question Language:</label>
                            <div class="radio-group" id="questionLangGroup">
                                <!-- Dynamic radio buttons will be inserted here -->
                            </div>
                        </div>
                        <div class="lang-option">
                            <label>Answer Language:</label>
                            <div class="radio-group" id="answerLangGroup">
                                <!-- Dynamic radio buttons will be inserted here -->
                            </div>
                        </div>
                    </div>

                    <div class="quiz-row quiz-row-bottom">
                        <button id="prevQ" aria-label="Previous question" class="touch-target">‚¨ÖÔ∏è</button>
                        <button id="nextQ" aria-label="Next question" class="touch-target">‚û°Ô∏è</button>
                        <button id="retryQuiz" aria-label="Retry quiz" class="touch-target">üîÑ</button>
                        <span id="score">Score: 0/0</span>
                        <label>
                            <input type="checkbox" id="incorrectOnly" aria-label="Show only incorrect questions">
                                Incorrect Only
                        </label>
                    </div>
                </div>
            </section>`;
            },

            getControlsHTML() {
                return ''; // Controls are handled by individual components
            },

            bindUIElements() {
                // Get navigation elements
                const topicSelect = document.getElementById('topicSelect');
                const titleSelect = document.getElementById('titleSelect');
                const exampleSelect = document.getElementById('exampleSelect');

                // Initialize navigation controller
                NavigationController.init(topicSelect, titleSelect, exampleSelect);

                // Bind playback controls
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const restartBtn = document.getElementById('restartBtn');
                const prevExample = document.getElementById('prevExample');
                const nextExample = document.getElementById('nextExample');

                if (playBtn) playBtn.addEventListener('click', () => PlaybackController.playExample());
                if (pauseBtn) pauseBtn.addEventListener('click', () => PlaybackController.pauseExample());
                if (restartBtn) restartBtn.addEventListener('click', () => PlaybackController.restartExample());
                if (prevExample) prevExample.addEventListener('click', () => NavigationController.previousExample());
                if (nextExample) nextExample.addEventListener('click', () => NavigationController.nextExample());

                // Bind quiz controls
                const prevQ = document.getElementById('prevQ');
                const nextQ = document.getElementById('nextQ');
                const retryQuiz = document.getElementById('retryQuiz');
                const incorrectOnly = document.getElementById('incorrectOnly');

                if (prevQ) prevQ.addEventListener('click', () => QuizSystem.previousQuestion());
                if (nextQ) nextQ.addEventListener('click', () => QuizSystem.nextQuestion());
                if (retryQuiz) retryQuiz.addEventListener('click', () => QuizSystem.retry());
                if (incorrectOnly) incorrectOnly.addEventListener('change', (e) => QuizSystem.toggleIncorrectOnly(e.target.checked));

                // Bind settings button
                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', () => SettingsManager.show());
                }

                // Bind playback delay
                const playbackDelay = document.getElementById('playbackDelay');
                if (playbackDelay) {
                    playbackDelay.value = Storage.load(CONSTANTS.STORAGE_KEYS.PLAYBACK_DELAY, CONSTANTS.DEFAULT_VALUES.PLAYBACK_DELAY);
                    playbackDelay.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.PLAYBACK_DELAY, e.target.value);
                    });
                }
            },

            async loadTopics() {
                try {
                    const topics = await TopicManager.loadTopicList();
                    AppState.topics = topics;
                    this.populateTopicSelect();

                    // Load the saved or first topic
                    const savedTopic = Storage.load(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC);
                    const topicToLoad = savedTopic || (topics.length > 0 ? topics[0].topicFilename : '');

                    if (topicToLoad) {
                        await this.loadTopic(topicToLoad);
                    }
                } catch (error) {
                    console.error('Error loading topics:', error);
                    ErrorHandler.showErrorToUser('Failed to load topics. Please check your connection.');
                }
            },

            populateTopicSelect() {
                const topicSelect = document.getElementById('topicSelect');
                if (!topicSelect) return;

                topicSelect.innerHTML = '';
                AppState.topics.forEach((topic, index) => {
                    const option = document.createElement('option');
                    option.value = topic.topicFilename;
                    option.textContent = topic.topic;
                    topicSelect.appendChild(option);
                });

                // Set the current topic
                if (AppState.currentTopic?.topicFilename) {
                    topicSelect.value = AppState.currentTopic.topicFilename;
                }
            },

            async loadTopic(topicFilename) {
                try {
                    const topicData = await TopicManager.loadTopic(topicFilename);
                    AppState.currentTopic = topicData;
                    AppState.currentTitle = 0;
                    AppState.currentExample = 0;

                    this.populateTitles();
                    this.populateExamples();
                    this.loadExample();

                    Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC, topicFilename);
                } catch (error) {
                    console.error('Error loading topic:', error);
                    ErrorHandler.showErrorToUser(`Failed to load topic: ${error.message}`);
                }
            },

            populateTitles() {
                const titleSelect = document.getElementById('titleSelect');
                if (!titleSelect || !AppState.currentTopic) return;

                titleSelect.innerHTML = '';
                AppState.currentTopic.titles.forEach((title, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = title.title || `Title ${index + 1}`;
                    titleSelect.appendChild(option);
                });

                titleSelect.value = AppState.currentTitle;
            },

            populateExamples() {
                const exampleSelect = document.getElementById('exampleSelect');
                if (!exampleSelect || !AppState.currentTopic) return;

                const currentTitle = AppState.currentTopic.titles[AppState.currentTitle];
                if (!currentTitle) return;

                exampleSelect.innerHTML = '';
                const examples = currentTitle.examples || [];

                examples.forEach((example, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Example ${index + 1}`;
                    exampleSelect.appendChild(option);
                });

                exampleSelect.value = AppState.currentExample;
            },

            loadExample() {
                AppState.saveNavigation();
                this.renderExample();

                AppState.currentWordIndex = 0;
                AppState.isPlaying = false;
                TTSManager.cancel();

                this.updateExampleNumber();
                this.updateProgressBar();

                // Ensure quiz language options are refreshed
                setTimeout(() => {
                    LanguageManager.renderQuizLanguageOptions();
                    this.ensureTopicSelectionVisible();
                }, 200);
            },

            renderExample() {
                const currentTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                const examples = currentTitle?.examples;
                const example = examples?.[AppState.currentExample] || [];
                ExampleRenderer.render(example);
                QuizSystem.buildFromExample(example);
            },

            updateExampleNumber() {
                const currentExampleNumber = document.getElementById('currentExampleNumber');
                if (currentExampleNumber) {
                    currentExampleNumber.textContent = AppState.currentExample + 1;
                }
            },

            updateProgressBar() {
                const progressBar = document.getElementById('progressBar');
                if (!progressBar || !AppState.currentTopic) return;

                const percentage = ProgressTracker.getCompletionPercentage(
                    AppState.currentTopic.topicFilename,
                    AppState.currentTopic
                );
                progressBar.style.width = `${percentage}%`;
            },

            ensureTopicSelectionVisible() {
                const topicOptionsDetails = document.getElementById('topicOptionsDetails');
                if (topicOptionsDetails && !topicOptionsDetails.open) {
                    topicOptionsDetails.open = true;
                }
            },

            restoreSettings() {
                // Restore any settings that need to be applied
                FontManager.apply();

                // Re-initialize navigation
                const topicSelect = document.getElementById('topicSelect');
                const titleSelect = document.getElementById('titleSelect');
                const exampleSelect = document.getElementById('exampleSelect');
                NavigationController.init(topicSelect, titleSelect, exampleSelect);
            }
        };
        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', () => {
            AppController.initSPA();
            AppController.init();
        });

    </script>


</body>

</html>