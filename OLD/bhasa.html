<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai&family=Chakra+Petch&display=swap"
        rel="stylesheet" />
    <title>ฝึกฝน Language Learner</title>
    <link rel="icon" type="image/x-icon" href="/assets/bhasa/images/favicon.ico">
    <link rel="stylesheet" href="/assets/bhasa/stylesheet/bhasa.css">
    <style>
        /* =========================================================
   0️⃣  ROOT VARIABLES (THEME & COLOURS)
   ========================================================= */
        :root {
            --primary-color: #00247D;
            --primary-light: #66aaff;
            --background-light: #f9f9f9;
            --background-dark: #222;
            --text-light: #000;
            --text-dark: #eee;
            --border-light: #ccc;
            --border-dark: #555;
            --correct-color: #4caf50;
            --incorrect-color: #f44336;
            --highlight-light: yellow;
            --highlight-dark: orange;
            --header-height: 60px;
        }

        /* =========================================================
   1️⃣  GLOBAL PAGE STYLING (MOBILE‑FIRST)
   ========================================================= */
        body {
            font-size: clamp(14px, 2.5vw, 18px);
            font-family: Arial, Helvetica, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--background-light);
            color: var(--text-light);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background .3s, color .3s;
        }

        body[data-theme="dark"] {
            background: var(--background-dark);
            color: var(--text-dark);
        }

        /* =========================================================
   2️⃣  HEADER
   ========================================================= */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--primary-color);
            color: #fff;
            padding: 0.3em 1em;
            min-height: 2.5em;
            flex-shrink: 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        #appTitle {
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
        }

        #headerControls {
            display: flex;
            align-items: center;
            gap: 0.8em;
        }

        #themeToggle,
        #settingsBtn {
            background: none !important;
            border: none !important;
            color: #fff;
            padding: 0.3em;
            cursor: pointer;
            font-size: 1.1rem;
            height: 2em;
            width: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background .2s;
        }

        #themeToggle:hover,
        #settingsBtn:hover {
            background: rgba(255, 255, 255, .1) !important;
        }

        /* -------- Mobile header tweaks -------- */
        @media (max-width: 600px) {
            header {
                padding: 0.3em 0.8em;
            }

            #appTitle {
                font-size: 1.1rem;
            }

            #headerControls {
                gap: 0.6em;
                font-size: 0.9rem;
            }

            #themeToggle,
            #settingsBtn {
                height: 1.8em;
                width: 1.8em;
                font-size: 1rem;
            }
        }

        /* =========================================================
   3️⃣  MAIN LAYOUT
   ========================================================= */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 1em;
            -webkit-overflow-scrolling: touch;
            scroll-margin-top: 120px;
            scroll-behavior: smooth;
        }

        .controls-area {
            background: var(--background-light);
            border-top: 1px solid var(--border-light);
            padding: 1em;
            flex-shrink: 0;
            position: sticky;
            bottom: 0;
            z-index: 90;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, .1);
        }

        body[data-theme="dark"] .controls-area {
            background: var(--background-dark);
            border-top-color: var(--border-dark);
        }

        /* -------- Sections & Details -------- */
        section {
            margin-bottom: 1.5em;
            padding-bottom: 1em;
            border-bottom: 1px solid var(--border-light);
        }

        body[data-theme="dark"] section {
            border-bottom-color: var(--border-dark);
        }

        details {
            padding: 0.5em 1em;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            margin: 0.5em 0;
            background: var(--background-light);
            color: var(--text-light);
        }

        details summary {
            cursor: pointer;
            color: var(--primary-color);
        }

        body[data-theme="dark"] details {
            background: #2a2a2a;
            border-color: var(--border-dark);
            color: var(--text-dark);
        }

        body[data-theme="dark"] details summary {
            color: var(--primary-light);
        }

        /* =========================================================
   4️⃣  FORM ELEMENTS (COMMON)
   ========================================================= */
        button,
        select,
        input[type="number"] {
            font-size: 1em;
            line-height: 1.5;
            padding: 0.4em 0.6em;
            height: 2em;
            border-radius: 4px;
            border: 1px solid var(--border-light);
            background: #f0f0f0;
            color: var(--text-light);
            cursor: pointer;
            box-sizing: border-box;
            transition: background .2s, color .2s, border-color .2s;
        }

        input[type="number"] {
            text-align: center;
        }

        button:hover,
        select:hover,
        input[type="number"]:hover {
            background: #e0e0e0;
        }

        body[data-theme="dark"] button,
        body[data-theme="dark"] select,
        body[data-theme="dark"] input[type="number"] {
            background: #333;
            border-color: var(--border-dark);
            color: var(--text-dark);
        }

        body[data-theme="dark"] button:hover,
        body[data-theme="dark"] select:hover,
        body[data-theme="dark"] input[type="number"]:hover {
            background: #444;
        }

        /* -------- Touch‑friendly -------- */
        .touch-target {
            min-height: 44px;
            min-width: 44px;
        }

        /* =========================================================
   5️⃣  EXAMPLE DISPLAY
   ========================================================= */
        #exampleDisplay {
            margin: 0.5em 0 1em;
            white-space: pre-wrap;
            min-height: 150px;
            max-height: 45vh;
            overflow-y: auto;
            padding: 1em;
            border: 1px solid var(--border-light);
            border-radius: 8px;
            background: var(--background-light);
        }

        body[data-theme="dark"] #exampleDisplay {
            background: #2a2a2a;
            border-color: var(--border-dark);
        }

        /* -------- Word‑pair styling -------- */
        .word-pair {
            display: inline-block;
            vertical-align: top;
            margin: 0 0.3em 0.5em 0;
            cursor: pointer;
            padding: 0.2em;
            border-radius: 3px;
            transition: background-color .2s;
        }

        .word-pair:hover {
            background-color: rgba(0, 36, 125, .1);
        }

        body[data-theme="dark"] .word-pair:hover {
            background-color: rgba(102, 170, 255, .1);
        }

        /* Language‑specific spans (all share same base) */
        .word-pair span[lang] {
            display: block;
            word-break: keep-all;
            overflow-wrap: break-word;
            font-size: large;
            border-top: 1px solid lightskyblue;
            margin-top: 0.1em;
            font-size: 0.9em;
        }

        /* Colour tweaks for specific languages */
        .word-pair span[lang="fa-IR"] {
            color: green;
            direction: rtl;
        }

        .word-pair span[lang="zh-CN"] {
            color: rgb(247, 5, 5);
        }

        .word-pair span[lang="ja-JP"] {
            color: rgb(154, 5, 247);
        }

        /* default colour for other languages */
        .word-pair span[lang]:not([lang="th-TH"]):not([lang="fa-IR"]) {
            color: rgb(5, 154, 247);
        }

        /* -------- Highlighting (used by playback & quiz) -------- */
        .highlight-light {
            background: var(--highlight-light);
            color: black;
        }

        .highlight-dark {
            background: var(--highlight-dark);
            color: black;
        }

        /* =========================================================
   6️⃣  PROGRESS BAR
   ========================================================= */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--border-light);
            border-radius: 3px;
            margin: 0.5em 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            transition: width .3s ease;
        }

        body[data-theme="dark"] .progress-bar {
            background: var(--border-dark);
        }

        /* =========================================================
   7️⃣  TOPIC & EXAMPLE SELECTION CONTROLS
   ========================================================= */
        #topicSelectionControls {
            background: rgba(0, 36, 125, .05);
            padding: 1em;
            border-radius: 8px;
            margin-bottom: 1em;
            position: sticky;
            top: 0;
            z-index: 80;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-light);
        }

        body[data-theme="dark"] #topicSelectionControls {
            background: rgba(102, 170, 255, .1);
            border-color: var(--border-dark);
        }

        #topicSelectionControls label {
            display: flex;
            align-items: center;
            gap: 0.5em;
            font-weight: bold;
        }

        @media (min-width: 600px) {
            #topicSelectionControls {
                display: flex;
                flex-wrap: wrap;
                gap: 1em;
                align-items: center;
                justify-content: space-between;
            }

            #topicSelectionControls label {
                flex: 1;
            }
        }

        /* -------- Language grid (used in Settings & Topic) -------- */
        .language-grid {
            display: grid;
            grid-template-columns: 60% 20% 20%;
            /* Language | Display | Speak */
            gap: 0.4em 0.8em;
            align-items: center;
        }

        .language-grid-header {
            font-weight: bold;
            text-align: center;
        }

        .language-name {
            display: flex;
            align-items: center;
            gap: 0.4em;
        }

        .language-checkbox-cell {
            text-align: center;
        }

        /* Mobile adjustment for language grid */
        @media (max-width: 600px) {
            .language-grid {
                font-size: 0.85em;
            }
        }

        /* -------- Language‑options details (Settings) -------- */
        .language-controls {
            margin: 1em 0;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: var(--background-light);
            overflow: hidden;
        }

        body[data-theme="dark"] .language-controls {
            background: #2a2a2a;
            border-color: var(--border-dark);
        }

        .language-controls-summary {
            cursor: pointer;
            padding: 0.6em 1em;
            font-weight: bold;
            background: var(--primary-color);
            color: #fff;
            user-select: none;
        }

        .language-controls-summary::after {
            content: "▸";
            float: right;
            transition: transform .2s;
        }

        .language-controls[open] .language-controls-summary::after {
            transform: rotate(90deg);
        }

        .language-controls-content {
            padding: 0.8em 1em;
        }

        /* -------- Playback delay row -------- */
        .language-delay-row {
            display: flex;
            align-items: center;
            gap: 1em;
            padding: 0.5em 0;
            margin-top: 0.5em;
            border-top: 1px solid var(--border-light);
        }

        .delay-label {
            font-weight: bold;
            white-space: nowrap;
        }

        body[data-theme="dark"] .language-delay-row {
            border-top-color: var(--border-dark);
        }

        /* =========================================================
   8️⃣  EXAMPLE & QUIZ CONTROLS (UNIFIED)
   ========================================================= */
        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            align-items: center;
            justify-content: center;
        }

        /* Example controls (already existed) */
        .example-controls-row {
            composes: control-row;
        }

        /* Quiz controls – identical layout */
        .quiz-controls {
            composes: control-row;
            margin-top: 1rem;
        }

        /* Buttons inside both rows */
        .touch-target {
            padding: 0.4em 0.8em;
            font-size: 1rem;
            min-height: 2.2em;
            border-radius: 4px;
        }

        /* Score label & Incorrect‑Only checkbox */
        .quiz-score,
        .example-number-label {
            font-weight: bold;
            white-space: nowrap;
        }

        .quiz-checkbox,
        .example-number-container {
            margin-right: 1rem;
        }

        /* Mobile – stack vertically */
        @media (max-width: 600px) {
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
        }

        /* =========================================================
   9️⃣  QUIZ SPECIFIC STYLING
   ========================================================= */
        #quiz {
            margin-top: 1em;
        }

        .quiz-heading {
            font-weight: 600;
            margin-bottom: 0.5em;
        }

        .quiz-question {
            font-size: 1.25rem;
            margin: .1em 0;
            padding: 0.5em;
            background: rgba(0, 36, 125, .05);
            border-radius: 5px;
        }

        body[data-theme="dark"] .quiz-question {
            background: rgba(102, 170, 255, .1);
        }

        .quiz-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            margin-top: 0.5em;
        }

        .quiz-option {
            border: 1px solid var(--border-light);
            padding: 0.5em 0.8em;
            cursor: pointer;
            border-radius: 5px;
            flex: 1;
            min-width: 120px;
            text-align: center;
            transition: all .2s;
        }

        .quiz-option.correct {
            background: var(--correct-color);
            color: #fff;
            border-color: var(--correct-color);
        }

        .quiz-option.incorrect {
            background: var(--incorrect-color);
            color: #fff;
            border-color: var(--incorrect-color);
        }

        /* -------- Quiz control panel (Score, Incorrect Only, Language Options, Buttons) -------- */
        #score {
            font-weight: bold;
            white-space: nowrap;
        }

        #incorrectOnly {
            transform: scale(1.1);
            margin-right: 0.3em;
        }

        /* Language‑Options inside Quiz (details) */
        .quiz-language-options {
            margin: 0.5rem 0;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: var(--background-light);
            overflow: hidden;
        }

        body[data-theme="dark"] .quiz-language-options {
            background: #2a2a2a;
            border-color: var(--border-dark);
        }

        .quiz-language-summary {
            cursor: pointer;
            padding: 0.6em 1em;
            font-weight: bold;
            background: var(--primary-color);
            color: #fff;
            user-select: none;
        }

        .quiz-language-summary::after {
            content: "▸";
            float: right;
            transition: transform .2s;
        }

        .quiz-language-options[open] .quiz-language-summary::after {
            transform: rotate(90deg);
        }

        .quiz-language-content {
            padding: 0.8em 1em;
        }

        /* Layout for the two radio groups (Question & Answer) */
        .lang-option {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.8em;
            margin-bottom: 0.5em;
        }

        .lang-option>label:first-child {
            font-weight: bold;
            min-width: 120px;
            white-space: nowrap;
        }

        .lang-option .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.8em;
            align-items: center;
        }

        .lang-option .radio-group input[type="radio"] {
            transform: scale(1.1);
        }

        /* -------------------------------------------------------------
   10️⃣  SETTINGS OVERLAY (MODAL)
   ------------------------------------------------------------- */
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .6);
            z-index: 1000;
            overflow-y: auto;
            padding: 2rem;
            box-sizing: border-box;
        }

        .settings-overlay .settings-panel {
            background: var(--background-light);
            color: var(--text-light);
            max-width: 800px;
            margin: 0 auto;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, .3);
        }

        body[data-theme="dark"] .settings-overlay .settings-panel {
            background: var(--background-dark);
            color: var(--text-dark);
        }

        /* =========================================================
   11️⃣  LOADING OVERLAY
   ========================================================= */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #fff;
            font-size: 1.2em;
        }

        .loading-spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: .5em;
        }

        @keyframes spin {
            from {
                transform: rotate(0);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* =========================================================
   12️⃣  SCROLLBAR STYLING
   ========================================================= */
        .content-area::-webkit-scrollbar,
        #exampleDisplay::-webkit-scrollbar {
            width: 8px;
        }

        .content-area::-webkit-scrollbar-track,
        #exampleDisplay::-webkit-scrollbar-track {
            background: var(--background-light);
        }

        .content-area::-webkit-scrollbar-thumb,
        #exampleDisplay::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 4px;
        }

        /* Dark‑mode scrollbar colours */
        body[data-theme="dark"] .content-area::-webkit-scrollbar-track,
        body[data-theme="dark"] #exampleDisplay::-webkit-scrollbar-track {
            background: var(--background-dark);
        }

        body[data-theme="dark"] .content-area::-webkit-scrollbar-thumb,
        body[data-theme="dark"] #exampleDisplay::-webkit-scrollbar-thumb {
            background: var(--border-dark);
        }

        /* -------------------------------------------------------------
   13️⃣  SELECT Z‑INDEX (ensure dropdowns appear above overlays)
   ------------------------------------------------------------- */
        select:focus {
            position: relative;
            z-index: 1000;
        }

        /* -------------------------------------------------------------
   14️⃣  UTILITY CLASSES
   ------------------------------------------------------------- */
        .hidden {
            display: none !important;
        }

        .visible {
            display: block !important;
        }

        /* -------------------------------------------------------------
   15️⃣  END OF FILE
   ------------------------------------------------------------- */
    </style>
</head>

<body data-theme="light">
    <header>
        <span lang="th" id="appTitle">ฝึกฝน</span>
        <div id="headerControls">
            <button id="themeToggle" title="Toggle Day/Night" aria-label="Toggle theme">🌞</button>
            <button id="settingsBtn" title="Settings & Help" aria-label="Open settings">⚙️</button>
        </div>
    </header>
    <main>
        <!-- This is the only thing that stays in the HTML.
             Everything else is injected by AppController.getMainHTML() -->
        <div class="content-area" id="contentArea"></div>

        <div class="controls-area" id="controlsArea"></div>
    </main>

    <!-- The rest (status announcements, loading overlay, settings overlay, etc.)
         can stay as‑is because they are not generated by getMainHTML(). -->

    <!-- =========================================================
             SETTINGS OVERLAY – a modal that appears on top of the
             existing UI. It does NOT replace the toolbar or the main
             content, so the app state (example, language options, etc.)
             stays intact when the panel is opened/closed.
             ========================================================= -->
    <div id="settingsOverlay" class="settings-overlay" style="display:none;"></div>

    <!-- Screen reader announcements -->
    <div id="statusAnnouncement" aria-live="polite" aria-atomic="true"
        style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;"></div>

    <script>
        // ==================== CONSTANTS ====================
        const CONSTANTS = {
            STORAGE_KEYS: {
                THEME: 'theme',
                THAI_FONT: 'thaiFont',
                CURRENT_TOPIC: 'currentTopic',
                CURRENT_TITLE: 'currentTitle',
                CURRENT_EXAMPLE: 'currentExample',
                PLAYBACK_DELAY: 'playbackDelay',
                QUESTION_LANG: 'questionLang',
                ANSWER_LANG: 'answerLang'
            },
            DEFAULT_VALUES: {
                THEME: 'light',
                PLAYBACK_DELAY: '0.5',
                QUESTION_LANG: 'th-TH',
                ANSWER_LANG: 'en-US'
            },
            MAX_RETRIES: 3,
            RETRY_DELAY: 1000
        };

        // ==================== APP CONFIGURATION ====================
        const AppConfig = {
            data: null,
            availableLanguages: [],
            quizEnabledLanguages: [],

            async load() {
                try {
                    const response = await fetch('/assets/bhasa/bhasaSetup.json');
                    this.data = await response.json();
                    this.processLanguages();
                    return this.data;
                } catch (error) {
                    console.error('Failed to load app configuration:', error);
                    // Fallback to default configuration
                    this.data = this.getDefaultConfig();
                    this.processLanguages();
                    return this.data;
                }
            },

            processLanguages() {
                this.availableLanguages = Object.entries(this.data.languages).map(([code, config]) => ({
                    code,
                    ...config
                }));

                // DEBUG: Log all languages before filtering
                console.log('All languages before quiz filtering:', this.availableLanguages);

                this.quizEnabledLanguages = this.availableLanguages.filter(lang => {
                    const isEnabled = lang.quizEnabled;
                    console.log(`Language ${lang.code} (${lang.name}): quizEnabled = ${isEnabled}`);
                    return isEnabled;
                });

                // MANUAL OVERRIDE: Ensure Japanese is always included in quiz languages
                /*
                                const japaneseLang = this.availableLanguages.find(lang => lang.code === 'ja-JP');
                                if (japaneseLang && !this.quizEnabledLanguages.find(lang => lang.code === 'ja-JP')) {
                                    console.log('Manually adding Japanese to quiz languages');
                                    this.quizEnabledLanguages.push(japaneseLang);
                                }
                */
                console.log('Final quiz languages:', this.quizEnabledLanguages.map(l => l.code));
            },

            getDefaultConfig() {
                return {
                    app: {
                        name: "Bhasa Language Learner",
                        version: "2.0",
                        defaultTheme: "light",
                        supportedQuizModes: ["word"],
                        maxDisplayLanguages: 6,
                        defaultPlaybackDelay: 0.5
                    },
                    languages: {
                        "th-TH": {
                            name: "Thai",
                            nativeName: "ไทย",
                            fontFamily: "Noto Sans Thai, Tahoma, sans-serif",
                            rtl: false,
                            defaultDisplay: true,
                            defaultSpeak: true,
                            quizEnabled: true
                        },
                        "fa-IR": {
                            name: "Persian",
                            nativeName: "فارسی",
                            fontFamily: "Arial, sans-serif",
                            rtl: true,
                            defaultDisplay: false,
                            defaultSpeak: false,
                            quizEnabled: true
                        },
                        "en-US": {
                            name: "English",
                            nativeName: "English",
                            fontFamily: "Arial, sans-serif",
                            rtl: false,
                            defaultDisplay: false,
                            defaultSpeak: false,
                            quizEnabled: true
                        },
                        "ja-JP": {
                            name: "Japanese",
                            nativeName: "日本語",
                            fontFamily: "Arial, sans-serif",
                            rtl: false,
                            defaultDisplay: false,
                            defaultSpeak: false,
                            quizEnabled: true
                        }
                    },
                    features: {
                        enableSearch: true,
                        enableProgressTracking: true,
                        enableTTS: true,
                        enableQuiz: true
                    }
                };
            },

            getLanguage(code) {
                return this.availableLanguages.find(lang => lang.code === code);
            },

            getDisplayLanguages() {
                return this.availableLanguages.filter(lang =>
                    Storage.loadBool(`display_${lang.code}`, lang.defaultDisplay)
                );
            },

            getSpeakLanguages() {
                // Languages with the Speak flag set (or the default from config)
                const speakChecked = (this.availableLanguages || []).filter(lang =>
                    Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak)
                );

                // Also include any languages that are displayed, so the user can hear them
                // even if the Speak checkbox was accidentally left unchecked.
                const displayLangs = this.getDisplayLanguages();

                // Merge the two arrays, removing duplicates
                const combined = [...new Set([...speakChecked, ...displayLangs])];
                return combined;
            },
        };

        // ==================== ERROR HANDLER ====================
        const ErrorHandler = {
            wrap: (fn, context = '') => {
                return (...args) => {
                    try {
                        return fn(...args);
                    } catch (error) {
                        console.error(`Error in ${context}:`, error);
                        ErrorHandler.showErrorToUser(error.message);
                        return null;
                    }
                };
            },

            showErrorToUser: (message) => {
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.innerHTML = `
    <strong>Something went wrong</strong>
    <p>${ErrorHandler.sanitizeHTML(message)}</p>
    <button onclick="this.parentElement.remove()" style="margin-top: 0.5em;">Dismiss</button>
    `;
                    contentArea.prepend(errorDiv);
                }
            },

            showSuccessMessage: (message) => {
                const contentArea = document.getElementById('contentArea');
                if (contentArea) {
                    const successDiv = document.createElement('div');
                    successDiv.className = 'success-message';
                    successDiv.innerHTML = `
    <strong>Success</strong>
    <p>${ErrorHandler.sanitizeHTML(message)}</p>
    <button onclick="this.parentElement.remove()" style="margin-top: 0.5em;">Dismiss</button>
    `;
                    contentArea.prepend(successDiv);
                }
            },

            sanitizeHTML: (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        };

        // ==================== UTILITIES ====================
        const Utils = {
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            throttle: (func, limit) => {
                let inThrottle;
                return function (...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },

            generateId: () => {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            },

            setLoadingState: (isLoading) => {
                const overlay = document.getElementById('loadingOverlay');
                if (overlay) {
                    overlay.style.display = isLoading ? 'flex' : 'none';
                }
            }
        };

        // ==================== STORAGE MANAGER ====================
        const Storage = {
            save: (key, value) => {
                try {
                    localStorage.setItem(key, value);
                } catch (error) {
                    console.error('Storage error:', error);
                }
            },

            load: (key, defaultValue = '') => {
                try {
                    return localStorage.getItem(key) || defaultValue;
                } catch (error) {
                    console.error('Storage error:', error);
                    return defaultValue;
                }
            },

            loadInt: (key, defaultValue = 0) => {
                const value = Storage.load(key, defaultValue.toString());
                return parseInt(value, 10);
            },

            loadBool: (key, defaultValue = false) => {
                const value = Storage.load(key, defaultValue ? '1' : '0');
                return value === '1';
            },

            remove: (key) => {
                try {
                    localStorage.removeItem(key);
                } catch (error) {
                    console.error('Storage error:', error);
                }
            }
        };

        /*=== PATCH START: Default language selection on startup ===*/
        function initialiseLanguageDefaults() {
            // If no language preferences exist, set Thai & English as defaults
            const displayLangs = Storage.load(CONSTANTS.STORAGE_KEYS.DISPLAY_LANGUAGES);
            const speakLangs = Storage.load(CONSTANTS.STORAGE_KEYS.SPEAK_LANGUAGES);

            if (!displayLangs) {
                // Default: show Thai and English
                Storage.save(CONSTANTS.STORAGE_KEYS.DISPLAY_LANGUAGES,
                    JSON.stringify({ "th-TH": true, "en-US": true }));
            }

            if (!speakLangs) {
                // Default: speak Thai and English
                Storage.save(CONSTANTS.STORAGE_KEYS.SPEAK_LANGUAGES,
                    JSON.stringify({ "th-TH": true, "en-US": true }));
            }
        }
        initialiseLanguageDefaults();
        /*=== PATCH START – default Quiz languages on startup ===*/
        function initialiseQuizLanguageDefaults() {
            const qLang = Storage.load(CONSTANTS.STORAGE_KEYS.QUESTION_LANG);
            const aLang = Storage.load(CONSTANTS.STORAGE_KEYS.ANSWER_LANG);

            if (!qLang) {
                // Default: English for the question
                Storage.save(CONSTANTS.STORAGE_KEYS.QUESTION_LANG, 'en-US');
            }
            if (!aLang) {
                // Default: Thai for the answer
                Storage.save(CONSTANTS.STORAGE_KEYS.ANSWER_LANG, 'th-TH');
            }
        }
        initialiseQuizLanguageDefaults();
        /*=== PATCH END ===*/
        /*=== PATCH END ===*/

        // ==================== NETWORK MANAGER ====================
        const NetworkManager = {
            async fetchWithRetry(url, retries = CONSTANTS.MAX_RETRIES, delay = CONSTANTS.RETRY_DELAY) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url);
                        if (response.ok) return response;
                        if (response.status === 404) {
                            throw new Error(`File not found: ${url}`);
                        }
                        throw new Error(`HTTP ${response.status}`);
                    } catch (error) {
                        if (i === retries - 1) throw error;
                        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                    }
                }
            },

            async fetchJSON(url) {
                try {
                    const response = await this.fetchWithRetry(url);
                    return await response.json();
                } catch (error) {
                    console.warn(`Failed to load ${url}:`, error.message);
                    // Return empty/default data instead of throwing
                    if (url.includes('topicList.json')) {
                        return this.getDefaultTopicList();
                    }
                    if (url.includes('bhasaSetup.json')) {
                        return AppConfig.getDefaultConfig();
                    }
                    throw error; // Re-throw for topic files
                }
            },

            getDefaultTopicList() {
                return [
                    {
                        topicFilename: "greetings.json",
                        topic: "Greetings",
                        description: "Basic greetings and introductions",
                        languageCount: 4,
                        exampleCount: 5,
                        difficulty: "beginner"
                    }
                ];
            }
        };

        // ==================== SCREEN READER ANNOUNCER ====================
        const ScreenReader = {
            announce: (message, priority = 'polite') => {
                const announcement = document.getElementById('statusAnnouncement');
                if (announcement) {
                    announcement.setAttribute('aria-live', priority);
                    announcement.textContent = message;
                    // Clear after announcement
                    setTimeout(() => {
                        announcement.textContent = '';
                    }, 1000);
                }
            }
        };

        // ==================== ENHANCED TTS MANAGER ====================
        const TTSManager = {
            supportedVoices: [],
            testResults: {},
            voiceCache: new Map(),

            initialize() {
                this.loadVoices();
                speechSynthesis.addEventListener('voiceschanged', () => {
                    this.loadVoices();
                });
            },

            loadVoices() {
                this.supportedVoices = speechSynthesis.getVoices();
                this.voiceCache.clear();
            },

            isSupported() {
                return 'speechSynthesis' in window && typeof SpeechSynthesisUtterance !== 'undefined';
            },

            getLanguageVoices(lang) {
                return this.supportedVoices.filter(voice =>
                    voice.lang.startsWith(lang) || voice.lang.includes(lang)
                );
            },

            hasLanguageSupport(lang) {
                return this.getLanguageVoices(lang).length > 0;
            },

            testLanguage(lang, text) {
                return new Promise((resolve) => {
                    if (!this.isSupported()) {
                        resolve({ success: false, error: 'TTS not supported' });
                        return;
                    }

                    if (!this.hasLanguageSupport(lang)) {
                        resolve({ success: false, error: `No ${lang} voices available` });
                        return;
                    }

                    try {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.lang = lang;
                        utterance.volume = 0.7;

                        utterance.onend = () => {
                            resolve({ success: true, voices: this.getLanguageVoices(lang) });
                        };

                        utterance.onerror = (error) => {
                            resolve({ success: false, error: this.getFriendlyError(error.error) });
                        };

                        speechSynthesis.speak(utterance);
                    } catch (error) {
                        resolve({ success: false, error: error.message });
                    }
                });
            },

            async comprehensiveTest() {
                const tests = AppConfig.availableLanguages
                    .filter(lang => lang.defaultSpeak)
                    .map(lang => ({
                        lang: lang.code,
                        text: this.getTestText(lang.code),
                        name: lang.name
                    }));

                this.testResults = {};
                let allPassed = true;

                for (const test of tests) {
                    const result = await this.testLanguage(test.lang, test.text);
                    this.testResults[test.lang] = {
                        ...result,
                        name: test.name,
                        text: test.text
                    };

                    if (!result.success) {
                        allPassed = false;
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                return allPassed;
            },

            getTestText(langCode) {
                const texts = {
                    'th-TH': 'สวัสดี นี่คือการทดสอบเสียงพูดภาษาไทย',
                    'fa-IR': 'سلام، این تست گفتار فارسی است',
                    'en-US': 'Hello, this is English text-to-speech',
                    'zh-CN': '你好，这是中文文本转语音测试',
                    'ja-JP': 'こんにちは、これは日本語のテキスト読み上げテストです'
                };
                return texts[langCode] || `Test for ${langCode}`;
            },

            speak(text, lang, onEnd) {
                if (!text) return;

                const sanitizedText = ErrorHandler.sanitizeHTML(text);
                if (!sanitizedText) return;

                speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(sanitizedText);
                utterance.lang = lang;
                utterance.volume = 0.8;
                utterance.rate = 0.9;
                utterance.pitch = 1.0;

                if (onEnd) utterance.onend = onEnd;

                speechSynthesis.speak(utterance);
                ScreenReader.announce(`Speaking: ${sanitizedText.substring(0, 50)}...`);
            },

            cancel() {
                speechSynthesis.cancel();
                ScreenReader.announce('Speech cancelled');
            },

            pause() {
                speechSynthesis.pause();
                ScreenReader.announce('Speech paused');
            },

            resume() {
                speechSynthesis.resume();
                ScreenReader.announce('Speech resumed');
            },

            getFriendlyError(error) {
                const errorMap = {
                    'not-allowed': 'Microphone access denied. Please check browser permissions.',
                    'network': 'Network error. Please check your internet connection.',
                    'audio-busy': 'Audio device is busy. Please try again.',
                    'audio-hardware': 'Audio hardware error. Please check your audio devices.',
                    'synthesis-failed': 'Speech synthesis failed. Please try again.',
                    'synthesis-unavailable': 'Speech synthesis unavailable for this language.'
                };
                return errorMap[error] || `An unexpected error occurred: ${error}`;
            },

            getSetupInstructions() {
                return `
    <div class="tts-setup-steps">
        <h4>Text-to-Speech Setup Instructions</h4>
        <div class="tts-step">
            <strong>Step 1: Install Language Packs</strong>
            <p>Go to your device settings and install the required language packs for:</p>
            <ul>
                ${AppConfig.availableLanguages.map(lang =>
                    `<li><strong>${lang.name}:</strong> Search for "${lang.name} language pack" in your device settings</li>`
                ).join('')}
            </ul>
        </div>
        <div class="tts-step">
            <strong>Step 2: Browser TTS Setup</strong>
            <p>In your browser settings:</p>
            <ul>
                <li>Chrome: Settings → Advanced → Accessibility → Text-to-Speech</li>
                <li>Firefox: Preferences → General → Language → Text-to-Speech</li>
                <li>Safari: System Preferences → Accessibility → Speech</li>
            </ul>
        </div>
        <div class="tts-step">
            <strong>Step 3: Enable Voices</strong>
            <p>Make sure the voices are enabled and set as default in your system's text-to-speech settings.</p>
        </div>
    </div>
    `;
            },

            getStatusMessage() {
                const supportedLanguages = AppConfig.availableLanguages.filter(lang =>
                    this.hasLanguageSupport(lang.code)
                );

                if (!this.isSupported()) {
                    return {
                        type: 'error',
                        title: 'TTS Not Supported',
                        message: 'Your browser does not support Text-to-Speech. Please use a modern browser like Chrome, Firefox, or Edge.'
                    };
                }

                if (supportedLanguages.length === 0) {
                    return {
                        type: 'error',
                        title: 'No TTS Voices Available',
                        message: 'No text-to-speech voices are available. Please install language packs following the instructions below.'
                    };
                }

                const availableNames = supportedLanguages.map(lang => lang.name);
                const missingLanguages = AppConfig.availableLanguages
                    .filter(lang => !this.hasLanguageSupport(lang.code))
                    .map(lang => lang.name);

                if (missingLanguages.length > 0) {
                    return {
                        type: 'warning',
                        title: 'Partial TTS Support',
                        message: `Available: ${availableNames.join(', ')}. Missing: ${missingLanguages.join(', ')}. Some features may not work properly.`
                    };
                }

                return {
                    type: 'success',
                    title: 'TTS Fully Supported',
                    message: `All languages are available: ${availableNames.join(', ')}. Text-to-speech is ready to use.`
                };
            }
        };

        // ==================== PROGRESS TRACKER ====================
        const ProgressTracker = {
            saveProgress: ErrorHandler.wrap((topicId, titleIndex, exampleIndex, score) => {
                const progress = {
                    lastAccessed: new Date().toISOString(),
                    currentTitle: titleIndex,
                    currentExample: exampleIndex,
                    scores: ProgressTracker.getScores(topicId),
                    completedExamples: ProgressTracker.getCompletedExamples(topicId)
                };

                progress.scores[`${titleIndex}-${exampleIndex}`] = score;
                progress.completedExamples.add(`${titleIndex}-${exampleIndex}`);

                Storage.save(`progress-${topicId}`, JSON.stringify(progress));
            }, 'ProgressTracker.saveProgress'),

            getProgress: ErrorHandler.wrap((topicId) => {
                const progress = Storage.load(`progress-${topicId}`);
                return progress ? JSON.parse(progress) : {
                    lastAccessed: null,
                    currentTitle: 0,
                    currentExample: 0,
                    scores: {},
                    completedExamples: new Set()
                };
            }, 'ProgressTracker.getProgress'),

            getCompletionPercentage: ErrorHandler.wrap((topicId, topicData) => {
                const progress = ProgressTracker.getProgress(topicId);
                const totalExamples = topicData.titles?.reduce((total, title) =>
                    total + (title.examples?.length || 0), 0) || 0;

                if (totalExamples === 0) return 0;

                return Math.round((progress.completedExamples.size / totalExamples) * 100);
            }, 'ProgressTracker.getCompletionPercentage'),

            getScores: (topicId) => {
                const progress = ProgressTracker.getProgress(topicId);
                return progress.scores || {};
            },

            getCompletedExamples: (topicId) => {
                const progress = ProgressTracker.getProgress(topicId);
                return new Set(progress.completedExamples || []);
            }
        };

        // ==================== APPLICATION STATE ====================
        const AppState = {
            topics: [],
            currentTopic: null,
            currentTitle: 0,
            currentExample: 0,
            isPlaying: false,
            currentWordIndex: 0,
            lastHighlightedIndex: null,

            initialize() {
                this.currentTopic = Storage.load(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC, '');
                this.currentTitle = Storage.loadInt(CONSTANTS.STORAGE_KEYS.CURRENT_TITLE, 0);
                this.currentExample = Storage.loadInt(CONSTANTS.STORAGE_KEYS.CURRENT_EXAMPLE, 0);
            },

            saveNavigation() {
                Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_TITLE, this.currentTitle);
                Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_EXAMPLE, this.currentExample);

                if (this.currentTopic?.topicFilename) {
                    ProgressTracker.saveProgress(
                        this.currentTopic.topicFilename,
                        this.currentTitle,
                        this.currentExample,
                        QuizSystem.score
                    );
                }
            },

            getCurrentExample() {
                try {
                    const currentTitle = this.currentTopic?.titles?.[this.currentTitle];
                    const examples = currentTitle?.examples;
                    const example = examples?.[this.currentExample];

                    console.log('Current example data:', example);

                    if (!example) {
                        console.warn('No example found at current position');
                        return [];
                    }

                    // If it's already in word array format, return as-is
                    if (Array.isArray(example)) {
                        return example;
                    }

                    // Handle object format with translations
                    return example; // Let PlaybackController handle the conversion
                } catch (error) {
                    console.error('Error getting current example:', error);
                    return [];
                }
            },

            /*
                        convertTranslationsToWordArray(translations) {
                            const languages = Object.keys(translations);
                            const wordArrays = languages.map(lang => {
                                const content = translations[lang];
                                return Array.isArray(content) ? content : [content];
                            });
            
                            const maxLength = Math.max(...wordArrays.map(arr => arr.length));
                            const result = [];
            
                            for (let i = 0; i < maxLength; i++) {
                                const word = {};
                                languages.forEach((lang, langIndex) => {
                                    word[lang] = wordArrays[langIndex][i] || '';
                                });
                                result.push(word);
                            }
            
                            return result;
                        }
                        */

        };

        // ========== UI COMPONENTS ==========
        /*=== PATCH START – reliable theme toggle ===*/
        const ThemeManager = {
            init() {
                // ---------------------------------------------------------
                // 1️⃣  Ensure a theme value exists (fallback to default)
                // ---------------------------------------------------------
                const storedTheme = Storage.load(CONSTANTS.STORAGE_KEYS.THEME);
                const theme = storedTheme || CONSTANTS.DEFAULT_VALUES.THEME;
                this.set(theme);                     // apply the theme (also saves it)

                // ---------------------------------------------------------
                // 2️⃣  Bind the toggle button
                // ---------------------------------------------------------
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    // Remove any previous listeners (prevents double‑binding)
                    themeToggle.replaceWith(themeToggle.cloneNode(true));
                    const newToggle = document.getElementById('themeToggle');
                    newToggle.addEventListener('click', () => this.toggle());
                }
            },

            set(theme) {
                document.body.dataset.theme = theme;
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    themeToggle.textContent = theme === 'light' ? '🌞' : '🌙';
                    themeToggle.setAttribute('aria-label',
                        theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode');
                }
                Storage.save(CONSTANTS.STORAGE_KEYS.THEME, theme);
                ScreenReader.announce(`Theme set to ${theme} mode`);
            },

            toggle() {
                this.set(document.body.dataset.theme === 'light' ? 'dark' : 'light');
            }
        };
        /*=== PATCH END ===*/
        const FontManager = {
            init() {
                this.apply();
            },

            apply() {
                const font = Storage.load(CONSTANTS.STORAGE_KEYS.THAI_FONT, '');

                // Apply to body or a container element to cascade down
                const body = document.body;

                // Remove all font classes first
                body.classList.remove('thai-font', 'tahoma', 'noto', 'chakra');

                // Add base class and specific font class
                body.classList.add('thai-font');
                if (font === 'Tahoma') body.classList.add('tahoma');
                if (font === 'Noto Sans Thai') body.classList.add('noto');
                if (font === 'Chakra Petch') body.classList.add('chakra');

                // Also apply directly to app title for redundancy
                const appTitle = document.getElementById('appTitle');
                if (appTitle) {
                    appTitle.classList.add('thai-font');
                    appTitle.classList.remove('tahoma', 'noto', 'chakra');
                    if (font === 'Tahoma') appTitle.classList.add('tahoma');
                    if (font === 'Noto Sans Thai') appTitle.classList.add('noto');
                    if (font === 'Chakra Petch') appTitle.classList.add('chakra');
                }

                // Apply to font preview
                const fontPreview = document.getElementById('fontPreview');
                if (fontPreview) {
                    fontPreview.className = 'font-preview thai-font';
                    if (font === 'Tahoma') fontPreview.classList.add('tahoma');
                    if (font === 'Noto Sans Thai') fontPreview.classList.add('noto');
                    if (font === 'Chakra Petch') fontPreview.classList.add('chakra');
                }

                // Force re-render of example display if it exists
                const exampleDisplay = document.getElementById('exampleDisplay');
                if (exampleDisplay && exampleDisplay.innerHTML) {
                    // This will trigger the CSS to apply to the Thai text
                    const currentExample = AppState.getCurrentExample();
                    if (currentExample && currentExample.length > 0) {
                        ExampleRenderer.render(currentExample);
                    }
                }
            }
        };

        /* =========================================================
           LANGUAGE MANAGER
           ========================================================= */
        const LanguageManager = {
            /* ---------------------------------------------------------
               Initialise the manager – called after AppConfig is loaded.
               --------------------------------------------------------- */
            init() {
                // Store the master list of languages from AppConfig
                this.availableLanguages = AppConfig.availableLanguages || [];

                // Render the two distinct UI sections
                this.renderLanguageControls();      // Settings → Display / Speak grid
                this.renderQuizLanguageOptions();   // Quiz → Question / Answer radios

                // Bind all events (checkboxes + radios)
                this.bindLanguageEvents();
                this.bindQuizLanguageEvents();
            },

            /* ---------------------------------------------------------
               1️⃣  Render the **global** language grid (Display / Speak)
               --------------------------------------------------------- */
            renderLanguageControls() {
                const container = document.getElementById('languageControls');
                if (!container) {
                    console.warn('LanguageManager: #languageControls not found');
                    return;
                }
                container.innerHTML = '';   // clear any previous content

                // ---- Build the grid header + rows as a string ----
                let gridHTML = `
            <div class="language-grid language-grid-header">
                <div class="language-grid-header">Language</div>
                <div class="language-grid-header">Display</div>
                <div class="language-grid-header">Speak</div>
            </div>
        `;

                this.availableLanguages.forEach(lang => {
                    // Show English name + native script (if available)
                    const displayName = lang.nativeName ? `${lang.name} (${lang.nativeName})` : lang.name;

                    gridHTML += `
                <div class="language-grid-row">
                    <div class="language-name">
                        <span class="flag-icon flag-${lang.code.substring(0, 2)}"></span>
                        ${displayName}
                    </div>

                    <div class="language-checkbox-cell">
                        <input type="checkbox"
                               id="display_${lang.code}"
                               ${Storage.loadBool(`display_${lang.code}`, lang.defaultDisplay) ? 'checked' : ''}>
                    </div>

                    <div class="language-checkbox-cell">
                        <input type="checkbox"
                               id="speak_${lang.code}"
                               ${Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak) ? 'checked' : ''}>
                    </div>
                </div>
            `;
                });

                // Wrap the whole grid inside a <details> (collapsible Settings section)
                const detailsHTML = `
            <details class="language-controls" open>
                <summary class="language-controls-summary">Language Options</summary>
                <div class="language-controls-content">
                    ${gridHTML}
                </div>
            </details>
        `;

                container.innerHTML = detailsHTML;
            },

            /* ---------------------------------------------------------
               2️⃣  Render the **Quiz‑specific** language radios
               --------------------------------------------------------- */
            renderQuizLanguageOptions() {
                const questionGroup = document.getElementById('questionLangGroup');
                const answerGroup = document.getElementById('answerLangGroup');

                if (!questionGroup || !answerGroup) {
                    console.warn('LanguageManager: Quiz language groups not found');
                    return;
                }

                // Clean any previous content (prevents duplicate panels)
                const quizControls = document.getElementById('quizControls');
                if (quizControls) {
                    quizControls.querySelectorAll('.quiz-language-options')
                        .forEach(el => el.remove());
                }

                // Empty the groups before repopulating
                questionGroup.innerHTML = '';
                answerGroup.innerHTML = '';

                const quizLanguages = AppConfig.quizEnabledLanguages;

                const savedQuestionLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.QUESTION_LANG,
                    CONSTANTS.DEFAULT_VALUES.QUESTION_LANG   // default = English
                );
                const savedAnswerLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.ANSWER_LANG,
                    CONSTANTS.DEFAULT_VALUES.ANSWER_LANG     // default = Thai
                );

                // Build the radio buttons for each enabled quiz language
                quizLanguages.forEach(language => {
                    // ---- Question language radio ----
                    const qLabel = document.createElement('label');
                    qLabel.innerHTML = `
                <input type="radio" name="questionLang" value="${language.code}"
                       ${savedQuestionLang === language.code ? 'checked' : ''}>
                ${language.name}
            `;
                    questionGroup.appendChild(qLabel);

                    // ---- Answer language radio ----
                    const aLabel = document.createElement('label');
                    aLabel.innerHTML = `
                <input type="radio" name="answerLang" value="${language.code}"
                       ${savedAnswerLang === language.code ? 'checked' : ''}>
                ${language.name}
            `;
                    answerGroup.appendChild(aLabel);
                });

                // Wrap the two groups inside a closed <details> element
                const detailsWrapper = document.createElement('details');
                detailsWrapper.className = 'quiz-language-options';   // closed by default (no `open` attr)

                const summary = document.createElement('summary');
                summary.textContent = 'Language Options';
                detailsWrapper.appendChild(summary);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'quiz-language-content';
                // Preserve the label+radio groups (they are already appended to the DOM)
                contentDiv.appendChild(questionGroup.parentElement);
                contentDiv.appendChild(answerGroup.parentElement);
                detailsWrapper.appendChild(contentDiv);

                // Insert at the top of the quiz controls (above the buttons)
                if (quizControls) {
                    quizControls.insertBefore(detailsWrapper, quizControls.firstChild);
                }

                // Finally bind the change events for the new radios
                this.bindQuizLanguageEvents();
            },

            /* ---------------------------------------------------------
               3️⃣  Bind events for the **Display / Speak** checkboxes
               --------------------------------------------------------- */
            bindLanguageEvents() {
                this.availableLanguages.forEach(language => {
                    const displayCheckbox = document.getElementById(`display_${language.code}`);
                    const speakCheckbox = document.getElementById(`speak_${language.code}`);

                    // ----- DISPLAY checkbox -----
                    if (displayCheckbox) {
                        displayCheckbox.addEventListener('change', e => {
                            Storage.save(`display_${language.code}`, e.target.checked ? '1' : '0');
                            // Re‑render the example so the new visibility takes effect
                            AppController.renderExample();
                            ScreenReader.announce(`${language.name} display ${e.target.checked ? 'enabled' : 'disabled'}`);
                        });
                    }

                    // ----- SPEAK checkbox -----
                    if (speakCheckbox) {
                        speakCheckbox.addEventListener('change', e => {
                            const speakOn = e.target.checked;
                            Storage.save(`speak_${language.code}`, speakOn ? '1' : '0');
                            ScreenReader.announce(`${language.name} speech ${speakOn ? 'enabled' : 'disabled'}`);

                            // If the user enables SPEAK, also force DISPLAY on
                            if (speakOn) {
                                Storage.save(`display_${language.code}`, '1');
                                if (displayCheckbox) displayCheckbox.checked = true;
                                // Re‑render the example so the new column appears
                                AppController.renderExample();
                            }
                        });
                    }
                });
            },

            bindQuizLanguageEvents() {
                // Helper – debounce rapid changes (prevents UI freeze)
                const debouncedRefresh = Utils.debounce(() => {
                    console.debug('🔁 Debounced quiz rebuild');
                    QuizSystem.rebuildFromCurrentExample();
                }, 150);   // 150 ms debounce

                // ----- Question Language radios -----
                document.querySelectorAll('input[name="questionLang"]').forEach(radio => {
                    // Remove any old listeners (prevents duplication)
                    radio.replaceWith(radio.cloneNode(true));
                });
                document.querySelectorAll('input[name="questionLang"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.QUESTION_LANG, e.target.value);
                        const lang = AppConfig.getLanguage(e.target.value);
                        ScreenReader.announce(`Question language set to ${lang?.name || e.target.value}`);
                        debouncedRefresh();          // <-- use the debounced wrapper
                    });
                });

                // ----- Answer Language radios -----
                document.querySelectorAll('input[name="answerLang"]').forEach(radio => {
                    radio.replaceWith(radio.cloneNode(true));
                });
                document.querySelectorAll('input[name="answerLang"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.ANSWER_LANG, e.target.value);
                        const lang = AppConfig.getLanguage(e.target.value);
                        ScreenReader.announce(`Answer language set to ${lang?.name || e.target.value}`);
                        debouncedRefresh();          // <-- use the debounced wrapper
                    });
                });
            },

            /* ---------------------------------------------------------
               5️⃣  Helper getters – used by PlaybackController & UI
               --------------------------------------------------------- */
            /** Languages that should be displayed (checkboxes) */
            getDisplayLanguages() {
                return this.availableLanguages.filter(lang =>
                    Storage.loadBool(`display_${lang.code}`, lang.defaultDisplay)
                );
            },

            /** Languages that should be spoken (Speak checkboxes, falling back to Display) */
            getSpeakLanguages() {
                const speakChecked = this.availableLanguages.filter(lang =>
                    Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak)
                );

                // If none are explicitly checked, fall back to the displayed set
                return speakChecked.length > 0 ? speakChecked : this.getDisplayLanguages();
            },

            /** Languages that are enabled for the Quiz (subset of all languages) */
            getQuizLanguages() {
                return AppConfig.quizEnabledLanguages;
            }
        };

        /* -------------------------------------------------------------
           Export / expose globally (so other modules can call it)
           ------------------------------------------------------------- */
        window.LanguageManager = LanguageManager;
        /* -------------------------------------------------------------
           SettingsManager – handles the Settings & Help overlay.
           ------------------------------------------------------------- */
        const SettingsManager = {
            /** -------------------------------------------------------------
             *  Show the Settings panel.
             *  The panel is rendered inside the hidden #settingsOverlay
             *  element, which sits on top of the existing UI. This way the
             *  toolbar (gear icon, theme toggle, etc.) stays in the DOM and
             *  remains functional.
             *  ------------------------------------------------------------- */
            show() {
                const overlay = document.getElementById('settingsOverlay');
                if (!overlay) {
                    console.error('Settings overlay element not found');
                    return;
                }

                // ---------------------------------------------------------
                // 1️⃣  Populate the overlay with the Settings UI
                // ---------------------------------------------------------
                overlay.innerHTML = `
            <div class="settings-panel">
                <div style="display: flex; justify-content: space-between; align-items: center;
                            background: #00247D; color: white; padding: 0.5em 1em; border-radius: 8px;">
                    <h2 style="margin: 0;">Settings &amp; Help</h2>
                    <button id="closeX" aria-label="Close settings"
                            style="background: #666; color: white; border: none; padding: 0.5em; border-radius: 4px; cursor: pointer;">❌</button>
                </div>

                <div class="settings-content" style="padding: 1em;">
                    <!-- Thai Font selector -->
                    <div class="settings-font-controls">
                        <label style="margin: 0;">
                            Thai Font:
                            <select id="settingsThaiFont" aria-label="Select Thai font">
                                <option value="">Default</option>
                                <option value="Tahoma">Tahoma</option>
                                <option value="Noto Sans Thai">Noto Sans Thai</option>
                                <option value="Chakra Petch">Chakra Petch</option>
                            </select>
                        </label>
                    </div>
                    <div class="font-preview" id="fontPreview" aria-live="polite"
                         style="margin-top:0.5em; font-size:1.2em;">
                        ตัวอย่างข้อความภาษาไทย (Thai Text Sample)
                    </div>

<div class="settings-section" style="margin-top:1.5em;">
    <h3>Text‑to‑Speech Setup</h3>
    <p>
        This App relies on TTS language support and works best with the free open source
        <a href="https://www.mozilla.org/firefox/new/" target="_blank"
           style="color: var(--primary-light); text-decoration: underline;">
            Firefox browser (available for free download here for all devices).
        </a>
    </p>

    <button id="checkTTS" class="settings-button"
            style="padding:0.8em 1.5em; background:#00247D; color:white;
                   border:none; border-radius:4px; cursor:pointer; margin:1em 0;">
        🔊 Test TTS Setup &amp; Language Support
    </button>

    <div id="ttsStatus"></div>
    <div id="ttsSetupInstructions"></div>
    <div id="languageTests"></div>
</div>

                    <!-- Keyboard shortcuts -->
                    <div class="settings-section" style="margin-top:1.5em;">
                        <details class="keyboard-shortcuts-panel">
                            <summary style="font-weight:bold; font-size:1.1em; cursor:pointer;">
                                Keyboard Shortcuts
                            </summary>
                            <div class="keyboard-shortcuts" style="margin-top:0.5em;">
                                <div class="shortcut-item"><span>Play/Pause</span> <kbd class="shortcut-key">Space</kbd></div>
                                <div class="shortcut-item"><span>Next Example</span> <kbd class="shortcut-key">→</kbd></div>
                                <div class="shortcut-item"><span>Previous Example</span> <kbd class="shortcut-key">←</kbd></div>
                                <div class="shortcut-item"><span>Restart</span> <kbd class="shortcut-key">R</kbd></div>
                                <div class="shortcut-item"><span>Next Question</span> <kbd class="shortcut-key">N</kbd></div>
                                <div class="shortcut-item"><span>Open Settings</span> <kbd class="shortcut-key">S</kbd></div>
                            </div>
                        </details>
                    </div>

                    <div style="margin-top:2em; text-align:center;">
                        <button id="closeBtn" class="touch-target"
                                style="padding:0.6em 1.2em; background:#666; color:white;
                                       border:none; border-radius:4px; cursor:pointer;">
                            Close Settings
                        </button>
                    </div>
                </div>
            </div>
        `;

                // ---------------------------------------------------------
                // 2️⃣  Show the overlay (make it receive pointer events)
                // ---------------------------------------------------------
                overlay.style.display = 'block';
                overlay.style.pointerEvents = 'auto';   // allow interaction

                // ---------------------------------------------------------
                // 3️⃣  Wire the Close buttons (both X and bottom button)
                // ---------------------------------------------------------
                const closeX = document.getElementById('closeX');
                const closeBtn = document.getElementById('closeBtn');
                if (closeX) closeX.addEventListener('click', () => this.close());
                if (closeBtn) closeBtn.addEventListener('click', () => this.close());

                // ---------------------------------------------------------
                // 4️⃣  Wire the TTS test button
                // ---------------------------------------------------------
                const checkTTS = document.getElementById('checkTTS');
                if (checkTTS) {
                    checkTTS.addEventListener('click', () => this.performTTSCheck());
                }

                // ---------------------------------------------------------
                // 5️⃣  Initialise the Thai‑font selector
                // ---------------------------------------------------------
                const settingsThaiFont = document.getElementById('settingsThaiFont');
                if (settingsThaiFont) {
                    // Load the saved font (empty string means “Default”)
                    settingsThaiFont.value = Storage.load(CONSTANTS.STORAGE_KEYS.THAI_FONT, '');
                    settingsThaiFont.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.THAI_FONT, e.target.value);
                        FontManager.apply(); // Apply immediately
                        ScreenReader.announce(`Thai font changed to ${e.target.value || 'default'}`);
                    });
                }

                // ---------------------------------------------------------
                // 6️⃣  Show the current TTS status (success / warning / error)
                // ---------------------------------------------------------
                const status = TTSManager.getStatusMessage?.();
                this.showTTSStatus(status);

                // If TTS isn’t fully supported, show the installation instructions
                if (status?.type !== 'success') {
                    const instructions = TTSManager.getSetupInstructions?.();
                    document.getElementById('ttsSetupInstructions').innerHTML = instructions;
                }

                // ---------------------------------------------------------
                // 7️⃣  Announce for screen‑reader users
                // ---------------------------------------------------------
                ScreenReader.announce('Settings panel opened');
            },

            /** -------------------------------------------------------------
             *  Close the Settings panel.
             *  We explicitly read the current font selector value here to
             *  guarantee the choice is saved even if the `<select>`'s
             *  `change` event didn’t fire (e.g., user clicked Close before
             *  the element lost focus). After saving we re‑apply the font
             *  and theme, then hide the overlay.
             *  ------------------------------------------------------------- */
            /*=== PATCH START – re‑apply theme when Settings close ===*/
            close() {
                const overlay = document.getElementById('settingsOverlay');
                if (!overlay) return;

                // (same font‑saving logic as before…)

                overlay.style.display = 'none';
                overlay.style.pointerEvents = 'none';
                overlay.innerHTML = '';

                // Re‑apply theme (important after closing the overlay)
                ThemeManager.init();

                // (rest of the method unchanged…)
            },
            /*=== PATCH END ===*/
            /** -------------------------------------------------------------
             *  Show the current TTS status (success / warning / error) inside
             *  the Settings panel.
             *  ------------------------------------------------------------- */
            showTTSStatus(status) {
                const ttsStatus = document.getElementById('ttsStatus');
                if (!status || !ttsStatus) return;

                const statusClass = `tts-status-${status.type === 'warning' ? 'info' : status.type}`;
                ttsStatus.innerHTML = `
            <div class="tts-status-container ${statusClass}">
                <h4 style="margin:0 0 0.5em 0;">${status.title}</h4>
                <p style="margin:0;">${status.message}</p>
            </div>
        `;
            },

            /** -------------------------------------------------------------
             *  Perform a full TTS test for all languages that have the
             *  “Speak” flag enabled. Results are shown inside the Settings
             *  panel.
             *  ------------------------------------------------------------- */
            async performTTSCheck() {
                const ttsStatus = document.getElementById('ttsStatus');
                const checkBtn = document.getElementById('checkTTS');
                const languageTests = document.getElementById('languageTests');

                if (!ttsStatus || !checkBtn || !languageTests) return;

                checkBtn.innerHTML = '<span class="loading-spinner"></span> Testing TTS...';
                checkBtn.disabled = true;
                ttsStatus.innerHTML = '';
                languageTests.innerHTML = '';

                const testPassed = await TTSManager.comprehensiveTest();
                this.showLanguageTestResults();

                if (!testPassed) {
                    const instructions = TTSManager.getSetupInstructions?.();
                    document.getElementById('ttsSetupInstructions').innerHTML = instructions;
                }

                checkBtn.innerHTML = '✅ TTS Test Complete';
                checkBtn.disabled = false;

                const finalStatus = TTSManager.getStatusMessage?.();
                this.showTTSStatus(finalStatus);
            },

            /** -------------------------------------------------------------
             *  Render the per‑language test results inside the Settings panel.
             *  ------------------------------------------------------------- */
            showLanguageTestResults() {
                const languageTests = document.getElementById('languageTests');
                const results = TTSManager.testResults;

                if (!languageTests || Object.keys(results).length === 0) return;

                let html = `<h4>Language Test Results:</h4><div class="tts-language-check">`;

                for (const [lang, result] of Object.entries(results)) {
                    const language = AppConfig.getLanguage(lang);
                    const icon = result.success ? '✅' : '❌';
                    const resultClass = result.success ? 'success-check' : 'error-cross';
                    const voices = result.voices ? result.voices.map(v => v.name).join(', ') : 'No voices';

                    html += `
                <div style="flex:1; min-width:200px; padding:1em; background:rgba(0,0,0,0.05); border-radius:8px;">
                    <div style="font-weight:bold;">${icon} ${language?.name || lang}</div>
                    <div class="test-result ${resultClass}">
                        ${result.success ?
                            `<div class="success-list">Working – Available voices:<br>${voices}</div>` :
                            `Failed: ${result.error}. ${this.getLanguageSpecificHelp(lang, result.error)}`
                        }
                    </div>
                    <button onclick="testSingleLanguage('${lang}', '${result.text}')"
                        class="language-test"
                        style="margin-top:0.5em;">
                        Test ${language?.name || lang} Again
                    </button>
                </div>
            `;
                }

                html += `</div>`;
                languageTests.innerHTML = html;
            },

            /** -------------------------------------------------------------
             *  Provide language‑specific help text for common TTS errors.
             *  ------------------------------------------------------------- */
            getLanguageSpecificHelp(lang, error) {
                const language = AppConfig.getLanguage(lang);
                const helpMessages = {
                    'th-TH': `To fix Thai TTS: Install the Thai language pack in your OS settings, then enable Thai TTS in your browser.`,
                    'fa-IR': `To fix Persian/Farsi TTS: Install the Persian language pack in your OS settings.`,
                    'en-US': `To fix English TTS: Ensure English (United States) is installed and enabled for speech synthesis.`,
                    'ja-JP': `To fix Japanese TTS: Install the Japanese language pack in your OS settings and enable Japanese speech synthesis.`
                };
                return helpMessages[lang] || `Please check your system language settings and install the ${language?.name || lang} language pack.`;
            }
        };

        /* Expose SettingsManager globally so the toolbar can call it */
        window.SettingsManager = SettingsManager;
        /* Expose SettingsManager globally so the toolbar can call it */
        window.SettingsManager = SettingsManager;
        /* Global exposure – ensures the toolbar can always find SettingsManager */
        window.SettingsManager = SettingsManager;
        // Global function for testing individual languages
        window.testSingleLanguage = async function (lang, text) {
            const language = AppConfig.getLanguage(lang);
            const result = await TTSManager.testLanguage(lang, text);
            alert(`${language?.name || lang} TTS Test: ${result.success ? 'SUCCESS' : 'FAILED'}\n${result.success ? 'Voice is working properly' : 'Error: ' + result.error}`);
        };

        // ========== TOPIC MANAGEMENT ==========
        const TopicManager = {
            cache: new Map(),

            async loadTopicList() {
                try {
                    const topicList = await NetworkManager.fetchJSON('/assets/bhasa/topics/topicList.json');
                    return topicList.map(topic => ({
                        topicFilename: topic.topicFilename,
                        topic: topic.topic,
                        description: topic.description,
                        languageCount: topic.languageCount,
                        exampleCount: topic.exampleCount,
                        difficulty: topic.difficulty
                    }));
                } catch (error) {
                    console.error('Error loading topic list:', error);
                    ErrorHandler.showErrorToUser('Failed to load topics. Please check your connection.');
                    return [];
                }
            },

            async loadTopic(filename) {
                if (this.cache.has(filename)) {
                    return this.cache.get(filename);
                }

                try {
                    const topicData = await NetworkManager.fetchJSON(`/assets/bhasa/topics/${filename}`);
                    const processedData = this.processTopicData(topicData);
                    this.cache.set(filename, processedData);
                    return processedData;
                } catch (error) {
                    console.error('Error loading topic:', error);
                    throw error;
                }
            },

            // ------------------- TopicManager.processTopicData (new-format only) -------------------
            processTopicData(topicData) {
                // Strict: only accept the new-format structure
                if (!topicData || typeof topicData !== 'object' || !topicData.metadata || !Array.isArray(topicData.titles)) {
                    console.error('TopicManager.processTopicData: invalid topicData (expected new format):', topicData);
                    throw new Error('Topic file missing required fields (metadata/titles) - expected new format');
                }

                // Normalize titles & examples, guaranteeing id / translations / metadata exist
                const processedTitles = topicData.titles.map(titleItem => ({
                    title: titleItem.title || '',
                    description: titleItem.description || '',
                    examples: (Array.isArray(titleItem.examples) ? titleItem.examples : []).map(example => ({
                        id: example && example.id ? String(example.id) : Utils.generateId(),
                        translations: (example && example.translations && typeof example.translations === 'object') ? example.translations : {},
                        metadata: (example && example.metadata && typeof example.metadata === 'object') ? example.metadata : {}
                    }))
                }));

                return {
                    topic: topicData.metadata.topic || '',
                    description: topicData.metadata.description || '',
                    titles: processedTitles,
                    metadata: {
                        topic: topicData.metadata.topic || '',
                        description: topicData.metadata.description || '',
                        languageCount: Number(topicData.metadata.languageCount) || 0,
                        exampleCount: Number(topicData.metadata.exampleCount) || 0,
                        difficulty: topicData.metadata.difficulty || 'beginner',
                        version: topicData.metadata.version || '1.0'
                    }
                };
            },
            // -------------------------------------------------------------------------------------

            clearCache() {
                this.cache.clear();
            }
        };

        // ========== EXAMPLE RENDERING ==========
        const ExampleRenderer = {
            display: null,

            init(displayElement) {
                this.display = displayElement;
            },

            /** -------------------------------------------------------------
             *  Highlight a single word (by its zero‑based index) in the
             *  rendered example.  The renderer already knows how each span
             *  stores its word index in `data-index`, so we can locate it
             *  quickly, clear any previous highlight, and apply a theme‑aware
             *  background colour.
             *  ------------------------------------------------------------- */
            highlightWord(index) {
                // First clear any existing highlights
                this.clearHighlights();

                // Find the span that represents the word at `index`
                const span = this.display.querySelector(`[data-index="${index}"]`);
                if (!span) return;

                const themeCls = document.body.dataset.theme === 'dark' ? 'highlight-dark' : 'highlight-light';
                span.classList.add(themeCls);
                span.style.background = document.body.dataset.theme === 'dark' ? 'orange' : 'yellow';
            },

            /** -------------------------------------------------------------
             *  Render an example – accepts either the *new* array format
             *  or the original object that contains a `translations` map.
             *  In both cases we first normalise the data to an array of
             *  word‑objects, then render it.
             *  ------------------------------------------------------------- */
            render(example) {
                if (!this.display) return;

                // -----------------------------------------------------------------
                // 1️⃣  Normalise the payload – always end up with an array
                // -----------------------------------------------------------------
                let wordsArray;
                if (!example) {
                    this.display.textContent = 'No example content available.';
                    return;
                }

                if (Array.isArray(example)) {
                    // Already in the final shape
                    wordsArray = example;
                } else if (example.translations && typeof example.translations === 'object') {
                    // New JSON shape – convert the translations map to an array
                    wordsArray = this._flattenTranslations(example.translations);
                } else {
                    console.error('ExampleRenderer.render: unsupported example format', example);
                    this.display.textContent = 'Invalid example format.';
                    return;
                }

                if (wordsArray.length === 0) {
                    this.display.textContent = 'No example content available.';
                    return;
                }

                // -----------------------------------------------------------------
                // 2️⃣  Build the DOM fragment
                // -----------------------------------------------------------------
                const fragment = document.createDocumentFragment();

                wordsArray.forEach((word, idx) => {
                    // Newline handling – a word that is just "\n" (or empty) becomes a <br>
                    if (this._isNewline(word)) {
                        fragment.appendChild(document.createElement('br'));
                        return;
                    }

                    const pairDiv = document.createElement('div');
                    pairDiv.className = 'word-pair performance-optimized';
                    pairDiv.dataset.index = idx;

                    // Render each **display‑enabled** language
                    LanguageManager.getDisplayLanguages().forEach(lang => {
                        const txt = word[lang.code];
                        if (!txt) return;

                        const span = document.createElement('span');
                        span.textContent = txt;
                        span.lang = lang.code;
                        span.dataset.index = idx;
                        span.dataset.language = lang.code;
                        span.tabIndex = 0;
                        span.setAttribute('role', 'button');
                        span.setAttribute('aria-label', `Speak ${lang.name}: ${txt}`);

                        // Styling hooks
                        span.classList.add(`language-font-${lang.code}`);
                        if (lang.rtl) span.setAttribute('dir', 'rtl');
                        if (lang.code === 'th-TH') span.classList.add('thai-font');

                        // Click → speak (only if the language is enabled for speaking)
                        span.onclick = () => {
                            if (Storage.loadBool(`speak_${lang.code}`, lang.defaultSpeak)) {
                                PlaybackController.playWord(txt, lang.code, span, idx);
                            }
                        };
                        span.onkeydown = e => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                span.click();
                            }
                        };

                        pairDiv.appendChild(span);
                    });

                    // Only add the pair if at least one language was rendered
                    if (pairDiv.children.length) fragment.appendChild(pairDiv);
                });

                this.display.innerHTML = '';
                this.display.appendChild(fragment);
                this.applyLanguageStyling();
            },

            /** -------------------------------------------------------------
             *  Convert the `translations` map (the format used in greetings.json)
             *  into the uniform array of word‑objects that the rest of the app
             *  expects.
             *
             *  Input:
             *    {
             *      "th-TH": ["สวัสดี","ครับ"],
             *      "en-US": ["Hello","sir"],
             *      …
             *    }
             *
             *  Output:
             *    [
             *      { "th-TH":"สวัสดี", "en-US":"Hello", … },
             *      { "th-TH":"ครับ",   "en-US":"sir",   … }
             *    ]
             *  ------------------------------------------------------------- */
            _flattenTranslations(translations) {
                if (!translations || typeof translations !== 'object') return [];

                const langs = Object.keys(translations);
                // Guard against an empty translations object
                if (langs.length === 0) return [];

                const maxLen = Math.max(...langs.map(l => {
                    const arr = translations[l];
                    return Array.isArray(arr) ? arr.length : 1;
                }));

                const words = [];
                for (let i = 0; i < maxLen; i++) {   // ✅ fixed i++
                    const word = {};
                    langs.forEach(l => {
                        const arr = translations[l];
                        word[l] = (Array.isArray(arr) ? arr[i] : arr) ?? '';
                    });
                    words.push(word);
                }
                return words;
            },

            _isNewline(word) {
                // A word is a newline when *all* displayed languages are empty or "\n"
                return LanguageManager.getDisplayLanguages().every(lang => {
                    const txt = word[lang.code];
                    return txt === '\n' || (txt && txt.trim() === '');
                });
            },

            applyLanguageStyling() {
                // Apply RTL and font styling to all language elements
                AppConfig.availableLanguages.forEach(language => {
                    const elements = this.display.querySelectorAll(`[lang="${language.code}"]`);
                    elements.forEach(el => {
                        el.classList.add(`language-font-${language.code}`);
                        if (language.rtl) {
                            el.setAttribute('dir', 'rtl');
                        }
                    });
                });
            },

            clearHighlights() {
                if (!this.display) return;
                // Clear highlights from spans instead of whole word‑pairs
                this.display.querySelectorAll('.word-pair span[lang]').forEach(span => {
                    span.classList.remove('highlight-light', 'highlight-dark');
                    span.style.background = '';
                });
            }
        };

        /* -------------------------------------------------------------
           PlaybackController – handles Play / Pause / Restart and the
           word‑by‑word, language‑by‑language speech flow.
           ------------------------------------------------------------- */
        const PlaybackController = {
            /* -----------------------------------------------------------------
               State used by the controller
               ----------------------------------------------------------------- */
            currentTimeout: null,          // timeout handle for the inter‑word delay
            currentSentence: [],          // array of word‑objects that will be spoken
            isPlaying: false,             // true while the example is running
            isPaused: false,              // true while the user has hit “Pause”
            currentWordIndex: 0,          // index inside currentSentence
            currentLanguageIndex: 0,      // index inside the list of speak‑languages

            /* -----------------------------------------------------------------
               Public entry point – called when the user clicks the Play button
               ----------------------------------------------------------------- */
            async playExample() {
                // If we are already playing → pause
                if (this.isPlaying && !this.isPaused) {
                    this.pauseExample();
                    return;
                }

                // If we are paused → resume
                if (this.isPaused) {
                    this.resumeExample();
                    return;
                }

                // -----------------------------------------------------------------
                // Fresh start – build the sentence that will be spoken
                // -----------------------------------------------------------------
                const example = AppState.getCurrentExample();
                if (!example || (Array.isArray(example) && example.length === 0)) return;

                this.isPlaying = true;
                this.isPaused = false;
                this.currentSentence = this.prepareSentenceForPlayback(example);
                this.currentWordIndex = 0;
                this.currentLanguageIndex = 0;
                AppState.currentWordIndex = 0;

                ScreenReader.announce('Playback started');

                // -------------------------------------------------------------
                // NEW STEP – give the browser a moment to populate the voice list
                // -------------------------------------------------------------
                // Many browsers load the list of TTS voices asynchronously.
                // Waiting a short time (300 ms) ensures that `speakWord()`
                // will find the appropriate voice for the first word.
                await new Promise(r => setTimeout(r, 300));

                // NOTE: we do **not** highlight the whole pair here.
                // Each language will be highlighted right before it is spoken.
                await this.playbackLoop();
            },
            /* -----------------------------------------------------------------
               Pause – stops the timer and cancels any ongoing utterance
               ----------------------------------------------------------------- */
            pauseExample() {
                this.isPaused = true;
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                TTSManager.cancel();                 // stops the current utterance
                ScreenReader.announce('Playback paused');
            },

            /* -----------------------------------------------------------------
               Resume – continues from where we left off
               ----------------------------------------------------------------- */
            resumeExample() {
                if (!this.isPaused) return;          // nothing to do
                this.isPaused = false;
                this.isPlaying = true;
                ScreenReader.announce('Playback resumed');
                this.playbackLoop();                  // continue the loop
            },

            /* -----------------------------------------------------------------
               Restart – clears everything and starts from the first word
               ----------------------------------------------------------------- */
            restartExample() {
                this.stopPlayback();
                ExampleRenderer.clearHighlights();
                this.currentWordIndex = 0;
                this.currentLanguageIndex = 0;
                AppState.currentWordIndex = 0;
                this.playExample();
            },

            /* -----------------------------------------------------------------
               Stop – used by Restart and by the internal clean‑up logic
               ----------------------------------------------------------------- */
            stopPlayback() {
                this.isPlaying = false;
                this.isPaused = false;
                this.currentLanguageIndex = 0;
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                    this.currentTimeout = null;
                }
                TTSManager.cancel();
            },

            /* -----------------------------------------------------------------
               Core loop – walks through the sentence word‑by‑word
               ----------------------------------------------------------------- */
            async playbackLoop() {
                // -------------------------------------------------------------
                // 0️⃣  ALWAYS reset the pause flag at the start of each loop.
                // -------------------------------------------------------------
                this.isPaused = false;

                // -------------------------------------------------------------
                // 1️⃣  Debug – show that the loop has (re)started
                // -------------------------------------------------------------
                console.debug(`playbackLoop – word index ${this.currentWordIndex} (isPlaying=${this.isPlaying}, isPaused=${this.isPaused})`);
                if (!this.currentSentence || this.currentSentence.length === 0) {
                    console.warn('No sentence loaded; stopping playback.');
                    this.stopPlayback();
                    return;
                }

                // -------------------------------------------------------------
                // 2️⃣  Playback stopped → clean up and exit
                // -------------------------------------------------------------
                if (!this.isPlaying) {
                    this.cleanupPlayback();
                    return;
                }

                // -------------------------------------------------------------
                // 3️⃣  Paused → poll every 200 ms (only when the user explicitly
                //     clicks the Pause button; we already cleared accidental pauses)
                // -------------------------------------------------------------
                if (this.isPaused) {
                    setTimeout(() => this.playbackLoop(), 200);
                    return;
                }

                // -------------------------------------------------------------
                // 4️⃣  End of sentence → finish
                // -------------------------------------------------------------
                if (this.currentWordIndex >= this.currentSentence.length) {
                    this.completePlayback();
                    return;
                }

                // -------------------------------------------------------------
                // 5️⃣  **REMOVED** – we no longer highlight the whole word‑pair here.
                //     Per‑language highlighting is handled inside `playWord`,
                //     which clears previous highlights and then highlights the
                //     exact span for the language being spoken.
                // -------------------------------------------------------------

                // -------------------------------------------------------------
                // 6️⃣  Speak the current word in **each selected language**
                // -------------------------------------------------------------
                const word = this.currentSentence[this.currentWordIndex];
                await this.speakAllLanguagesForWord(word);

                // -------------------------------------------------------------
                // 7️⃣  Advance to the next word
                // -------------------------------------------------------------
                this.currentWordIndex++;
                this.currentLanguageIndex = 0;               // reset language counter
                AppState.currentWordIndex = this.currentWordIndex;

                // -------------------------------------------------------------
                // 8️⃣  Wait the user‑defined delay, then recurse
                // -------------------------------------------------------------
                const delay = this.getPlaybackDelay();       // ms (minimum 500 ms)

                // Use an await‑based delay (no stored timeout ID needed)
                await new Promise(r => setTimeout(r, delay));
                if (this.isPlaying && !this.isPaused) {
                    // Schedule next iteration asynchronously instead of direct recursion
                    requestAnimationFrame(() => this.playbackLoop());
                }
            },


            /* -----------------------------------------------------------------
               Speak every language that the user has ticked “Speak”.
               For each language we **highlight the exact span** that is being
               spoken, then call the low‑level TTS routine.
               The loop never aborts on a missing voice – it simply continues
               to the next language (or next word) after announcing the problem.
               ----------------------------------------------------------------- */
            async speakAllLanguagesForWord(word) {
                // 1️⃣  Get the list of languages that should be spoken.
                //      This method returns the union of “Speak” and “Display”
                //      languages, so every displayed language will be processed.
                const speakLanguages = LanguageManager.getSpeakLanguages();

                // 2️⃣  Defensive guard – should never be empty because we fall back,
                //      but keep the warning just in case.
                if (speakLanguages.length === 0) {
                    console.warn('No Speak languages selected – nothing will be spoken.');
                    return;
                }

                // 3️⃣  Log the languages we are about to process (helps debugging)
                console.debug('Speaking word with languages:',
                    speakLanguages.map(l => l.code));

                // 4️⃣  Loop over each language for the current word.
                for (let i = 0; i < speakLanguages.length; i++) {
                    const language = speakLanguages[i];

                    // ---------------------------------------------------------
                    // Grab the text for this language.
                    // ---------------------------------------------------------
                    const text = word[language.code];
                    if (!text || text === "\n" || text.trim() === '') {
                        console.debug(`No text for language "${language.code}" – skipping`);
                        continue; // Nothing to speak for this language
                    }

                    // ---------------------------------------------------------
                    // Find the exact <span> that represents this word‑language pair.
                    // ---------------------------------------------------------
                    const span = document.querySelector(
                        `.word-pair span[data-index="${this.currentWordIndex}"][data-language="${language.code}"]`
                    );

                    if (!span) {
                        // This should not happen if the language is also displayed,
                        // but we guard against it so the loop never gets stuck.
                        console.warn(`Span not found for language "${language.code}" at word index ${this.currentWordIndex}`);
                        continue; // Skip to the next language
                    }

                    // ---------------------------------------------------------
                    // Highlight the span **before** speaking.
                    // ---------------------------------------------------------
                    const themeCls = document.body.dataset.theme === 'dark' ? 'highlight-dark' : 'highlight-light';
                    span.classList.add(themeCls);
                    span.style.background = document.body.dataset.theme === 'dark' ? 'orange' : 'yellow';

                    // ---------------------------------------------------------
                    // Call playWord – it will invoke speakWord (which handles
                    // missing‑voice cases) and will clear the highlight when
                    // the utterance finishes.
                    // ---------------------------------------------------------
                    console.debug(`Calling playWord for language "${language.code}"`);
                    await this.playWord(text, language.code, span, this.currentWordIndex);
                    console.debug(`Finished playWord for language "${language.code}"`);

                    // ---------------------------------------------------------
                    // Small pause between languages so the speech doesn’t sound rushed.
                    // ---------------------------------------------------------
                    if (i < speakLanguages.length - 1) {
                        await new Promise(r => setTimeout(r, 200));
                    }
                }

                // 5️⃣  All languages for this word have been processed – reset the
                //     language index so the next word starts from the first language.
                this.currentLanguageIndex = 0;
            },

            /* -------------------------------------------------------------
               Build a uniform sentence array from the example data.
               The only supported format is:
               {
                   translations: {
                       "th-TH": ["สวัสดี","ครับ"],
                       "en-US": ["Hello","sir"],
                       …
                   }
               }
               ------------------------------------------------------------- */
            prepareSentenceForPlayback(example) {
                if (!example) return [];

                // New format – already an array of word objects (unlikely for our data)
                if (Array.isArray(example)) {
                    return example;
                }

                // New format with a `translations` map – this is the only format we support now
                if (example.translations && typeof example.translations === 'object') {
                    return this._flattenTranslations(example.translations);
                }

                // Anything else is a programmer error – surface it clearly
                console.error('Unsupported example format – expected a `translations` object:', example);
                return [];
            },

            /**
             * Convert the translations map into an array of word‑objects.
             *
             * Input:
             *   {
             *     "th-TH": ["สวัสดี","ครับ"],
             *     "en-US": ["Hello","sir"],
             *     …
             *   }
             *
             * Output:
             *   [
             *     { "th-TH":"สวัสดี", "en-US":"Hello", … },
             *     { "th-TH":"ครับ",   "en-US":"sir",   … }
             *   ]
             */
            _flattenTranslations(translations) {
                if (!translations || typeof translations !== 'object') return [];

                const langs = Object.keys(translations);
                // Guard against an empty translations object
                if (langs.length === 0) return [];

                const maxLen = Math.max(...langs.map(l => {
                    const arr = translations[l];
                    return Array.isArray(arr) ? arr.length : 1;
                }));

                const words = [];
                for (let i = 0; i < maxLen; i++) {   // ✅ fixed i++
                    const word = {};
                    langs.forEach(l => {
                        const arr = translations[l];
                        word[l] = (Array.isArray(arr) ? arr[i] : arr) ?? '';
                    });
                    words.push(word);
                }
                return words;
            },

            /* -----------------------------------------------------------------
               Helper: map the internal word index to the index that the UI uses.
               (At the moment they are the same, but keeping the indirection
               makes future tweaks easier.)
               ----------------------------------------------------------------- */
            getDisplayIndexForWord(wordIndex) {
                return wordIndex;
            },

            /* -----------------------------------------------------------------
               User‑configurable delay (seconds → milliseconds, minimum 500 ms)
               ----------------------------------------------------------------- */
            getPlaybackDelay() {
                const d = parseFloat(Storage.load(
                    CONSTANTS.STORAGE_KEYS.PLAYBACK_DELAY,
                    CONSTANTS.DEFAULT_VALUES.PLAYBACK_DELAY
                ));
                // Enforce 0.1 s steps (rounded to nearest tenth)
                const rounded = Math.round(d * 10) / 10;
                return Math.max(0.5, rounded * 1000);   // minimum 500 ms
            },

            /* -----------------------------------------------------------------
               Low‑level wrapper around the Web Speech API.
               Returns a promise that resolves **true** when the utterance ends
               (or when it times‑out) and **false** only on genuine TTS errors.
               If no matching voice is found, the promise resolves **true** after
               announcing the missing voice, allowing playback to continue.
               ----------------------------------------------------------------- */
            speakWord(text, lang) {
                return new Promise(async resolve => {
                    // 1️⃣  Guard – ignore empty strings or pure new‑lines
                    if (!text || text === "\n" || text.trim() === '') {
                        resolve(true);
                        return;
                    }

                    // 2️⃣  Verify that the browser actually supports Speech Synthesis
                    if (!('speechSynthesis' in window) ||
                        typeof SpeechSynthesisUtterance === 'undefined') {
                        console.warn('Speech synthesis not supported in this browser');
                        ScreenReader.announce('Speech synthesis is not supported in this browser.');
                        resolve(false);
                        return;
                    }

                    // 3️⃣  Make sure the voice list is populated.
                    let allVoices = speechSynthesis.getVoices();

                    if (allVoices.length === 0) {
                        console.debug('Voice list empty – waiting for voiceschanged event...');
                        await new Promise(r => {
                            const handler = () => {
                                speechSynthesis.removeEventListener('voiceschanged', handler);
                                r();
                            };
                            speechSynthesis.addEventListener('voiceschanged', handler);
                            // Fallback timeout in case the event never fires
                            setTimeout(r, 500);
                        });
                        allVoices = speechSynthesis.getVoices();
                    }

                    // 4️⃣  Filter for voices that actually support the requested language
                    const matchingVoices = allVoices.filter(v =>
                        v.lang && v.lang.toLowerCase().startsWith(lang.toLowerCase())
                    );

                    console.debug(`Found ${matchingVoices.length} voice(s) for language "${lang}"`);

                    // 5️⃣  No matching voice?  Announce the problem **but do not abort**.
                    if (matchingVoices.length === 0) {
                        const msg = `No Text‑to‑Speech voice found for language "${lang}". ` +
                            `Open the Help & Support panel and click “Test TTS Setup & Language Support” ` +
                            `to see how to install the required language pack.`;
                        console.warn(msg);
                        ScreenReader.announce(msg);

                        // Optional on‑screen banner (helps sighted users)
                        const banner = document.createElement('div');
                        banner.className = 'missing-voice-banner';
                        banner.textContent = msg;
                        banner.style.cssText = `
    position:fixed; top:0; left:0; width:100%;
    background:#ffeb3b; color:#000;
    padding:0.6em; text-align:center;
    font-weight:bold; z-index:1000;
`;
                        document.body.appendChild(banner);
                        setTimeout(() => banner.remove(), 8000);

                        // Resolve **true** so playback continues to the next language/word
                        resolve(true);
                        return;
                    }

                    // 6️⃣  Pick the first matching voice (good enough for our demo)
                    const chosenVoice = matchingVoices[0];
                    console.debug(`Using voice "${chosenVoice.name}" (lang=${chosenVoice.lang})`);

                    // 7️⃣  Build the utterance
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = lang;
                    utterance.voice = chosenVoice;
                    utterance.volume = 0.8;
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;

                    // 8️⃣  Resolve the promise when the utterance finishes or errors
                    let finished = false;
                    const finish = ok => {
                        if (finished) return;
                        finished = true;
                        clearTimeout(timeoutId);
                        resolve(ok);
                    };

                    utterance.onend = () => finish(true);
                    utterance.onerror = (e) => {
                        console.error('Speech synthesis error:', e.error);
                        ScreenReader.announce(`Speech error: ${e.error}`);
                        finish(false);
                    };

                    // 9️⃣  Safety net – timeout after 5 seconds
                    const timeoutId = setTimeout(() => {
                        console.warn(`Speech synthesis timeout for language "${lang}"`);
                        ScreenReader.announce(`Speech timed out for language ${lang}`);
                        finish(false);
                    }, 5000);

                    // 🔟  Finally, speak!
                    speechSynthesis.speak(utterance);
                });
            },

            /* -----------------------------------------------------------------
               Cleanup helpers – called when playback finishes or is aborted
               ----------------------------------------------------------------- */
            cleanupPlayback() {
                this.isPlaying = false;
                this.isPaused = false;
                this.currentWordIndex = 0;
                this.currentLanguageIndex = 0;
                AppState.currentWordIndex = 0;
                ExampleRenderer.clearHighlights();
            },

            completePlayback() {
                this.cleanupPlayback();
                ScreenReader.announce('Playback completed');
            },

            /* -----------------------------------------------------------------
               Click‑handler for a single word (used by the UI)
               ----------------------------------------------------------------- */
            async playWord(text, lang, element, index) {
                if (!text || text.trim() === '') return;

                // Clear any previous per‑span highlight first
                ExampleRenderer.clearHighlights();

                // Highlight the span that is about to be spoken
                if (element) {
                    const themeCls = document.body.dataset.theme === 'dark' ? 'highlight-dark' : 'highlight-light';
                    element.classList.add(themeCls);
                    element.style.background = document.body.dataset.theme === 'dark' ? 'orange' : 'yellow';
                }

                // Actually speak the word
                await this.speakWord(text, lang);
                ScreenReader.announce(`Speaking: ${text}`);
            }
        };

        /* =========================================================
           QUIZ SYSTEM – works with the new word‑level format
           ========================================================= */
        const QuizSystem = {
            /* ---------------------------------------------------------
               Internal state
               --------------------------------------------------------- */
            data: [],                 // array of question objects
            currentQuestion: 0,       // index inside `data`
            score: 0,                 // correct answers count
            attempts: 0,              // total answered questions
            incorrectOnly: false,     // filter flag

            /* ---------------------------------------------------------
               PUBLIC API – rebuild the quiz from the **current** example.
               This method is called when the user changes the Question
               or Answer language radio buttons.
               --------------------------------------------------------- */
            rebuildFromCurrentExample() {
                const currentExample = AppState.getCurrentExample();

                // If we have a valid example, rebuild the quiz from it.
                if (currentExample && currentExample.length > 0) {
                    this.buildFromExample(currentExample);
                } else {
                    console.warn('QuizSystem.rebuildFromCurrentExample – no current example available');
                    this.data = [];
                    this.render();
                }
            },

            /* ---------------------------------------------------------
               Build the quiz from the currently displayed example
               --------------------------------------------------------- */
            buildFromExample(example) {
                if (!example || !example.translations) {
                    console.warn('QuizSystem.buildFromExample – invalid example', example);
                    this.data = [];
                    this.render();
                    return;
                }

                // -----------------------------------------------------------------
                // 1️⃣  Pull the parallel arrays out of the example
                // -----------------------------------------------------------------
                const trans = example.translations;
                const langs = Object.keys(trans);               // e.g. ["th-TH","en-US","fa-IR","ja-JP","zh-CN"]
                const length = trans[langs[0]].length;          // all arrays must be the same length

                // -----------------------------------------------------------------
                // 2️⃣  Determine which languages are currently selected for
                //     Question and Answer (fallback to defaults if none stored)
                // -----------------------------------------------------------------
                const qLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.QUESTION_LANG,
                    CONSTANTS.DEFAULT_VALUES.QUESTION_LANG   // default = English
                );
                const aLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.ANSWER_LANG,
                    CONSTANTS.DEFAULT_VALUES.ANSWER_LANG     // default = Thai
                );

                // -----------------------------------------------------------------
                // 3️⃣  Build a question object for each token (index i)
                // -----------------------------------------------------------------
                const questions = [];
                for (let i = 0; i < length; i++) {
                    const questionText = trans[qLang][i] ?? '';
                    const answerText = trans[aLang][i] ?? '';

                    // Skip tokens that are empty in either language
                    if (!questionText.trim() || !answerText.trim()) continue;

                    // Build three distractors (random other answers, ensure uniqueness)
                    const distractors = [];
                    while (distractors.length < 3) {
                        const randIdx = Math.floor(Math.random() * length);
                        const candidate = trans[aLang][randIdx];
                        if (
                            candidate &&
                            candidate !== answerText &&
                            !distractors.includes(candidate)
                        ) {
                            distractors.push(candidate);
                        }
                    }

                    const options = [answerText, ...distractors].sort(() => 0.5 - Math.random());

                    questions.push({
                        id: `q-${i}`,
                        question: questionText,
                        answer: answerText,
                        options,
                        attempted: false,
                        correct: false
                    });
                }

                this.data = questions;
                this.currentQuestion = 0;
                this.score = 0;
                this.attempts = 0;
                this.render();
            },

            /*
        
                    /* ---------------------------------------------------------
                       Rendering
                       --------------------------------------------------------- */
            render() {
                const container = document.getElementById('quiz');
                if (!container) return;

                const filtered = this.getFilteredQuestions();

                // -----------------------------------------------------------------
                // 0️⃣  No questions left → show a friendly message
                // -----------------------------------------------------------------
                if (filtered.length === 0) {
                    if (this.incorrectOnly) {
                        this.showNoIncorrectMessage(container);
                    } else {
                        this.showCompletionMessage(container);
                    }
                    return;
                }

                // -----------------------------------------------------------------
                // 1️⃣  Render the current question
                // -----------------------------------------------------------------
                const q = filtered[this.currentQuestion];
                const qLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.QUESTION_LANG,
                    CONSTANTS.DEFAULT_VALUES.QUESTION_LANG
                );
                const aLang = Storage.load(
                    CONSTANTS.STORAGE_KEYS.ANSWER_LANG,
                    CONSTANTS.DEFAULT_VALUES.ANSWER_LANG
                );

                container.innerHTML = `
            <div class="quiz-heading">Translate this word:</div>
            <div class="quiz-question" lang="${qLang}">${this.escapeHTML(q.question)}</div>
            <div class="quiz-options">
                ${q.options.map(opt => `
                    <div class="quiz-option ${q.attempted ? (opt === q.answer ? 'correct' : 'incorrect') : ''}"
                         data-option="${this.escapeHTML(opt)}"
                         onclick="QuizSystem.handleAnswer(this, '${this.escapeHTML(opt)}', ${this.currentQuestion}, '${aLang}')">
                        ${this.escapeHTML(opt)}
                    </div>
                `).join('')}
            </div>
        `;

                // ---------------------------------------------------------
                // 2️⃣  Attach click‑to‑speak listeners (question + answers)
                // ---------------------------------------------------------
                this.attachQuizListeners();

                // ---------------------------------------------------------
                // 3️⃣  Announce progress for screen readers
                // ---------------------------------------------------------
                ScreenReader.announce(`Question ${this.currentQuestion + 1} of ${filtered.length}`);
            },

            /* ---------------------------------------------------------
               Helper methods (escapeHTML, getFilteredQuestions, etc.)
               --------------------------------------------------------- */
            escapeHTML(txt) {
                const div = document.createElement('div');
                div.textContent = txt;
                return div.innerHTML;
            },

            getFilteredQuestions() {
                if (this.incorrectOnly) {
                    return this.data.filter(q => q.attempted && !q.correct);
                }
                return this.data.filter(q => !q.attempted || !this.incorrectOnly);
            },

            showNoIncorrectMessage(container) {
                container.innerHTML = `
            <div style="text-align:center;padding:2em;color:var(--text-light);">
                <p>🎉 No incorrect answers! Great job!</p>
                <p>Uncheck “Incorrect Only” to practice all questions again.</p>
            </div>
        `;
            },

            showCompletionMessage(container) {
                container.innerHTML = `
            <div style="text-align:center;padding:2em;color:var(--text-light);">
                <p>✅ Quiz completed!</p>
                <p>Score: ${this.score}/${this.attempts}</p>
                <p>Click “Restart Quiz” to start over.</p>
            </div>
        `;
            },

            /* ---------------------------------------------------------
               Answer handling
               --------------------------------------------------------- */
            handleAnswer(optionEl, selectedOption, qIdx, answerLang) {
                const filtered = this.getFilteredQuestions();
                const q = filtered[qIdx];
                if (!q || q.attempted) return;   // safety

                const isCorrect = selectedOption === q.answer;
                q.attempted = true;
                q.correct = isCorrect;
                this.attempts++;

                if (isCorrect) {
                    optionEl.classList.add('correct');
                    this.score++;
                    ScreenReader.announce(`Correct! ${selectedOption}`);
                } else {
                    optionEl.classList.add('incorrect');
                    // Highlight the correct answer
                    document.querySelectorAll('.quiz-option').forEach(opt => {
                        if (opt.textContent === q.answer) opt.classList.add('correct');
                    });
                    ScreenReader.announce(`Incorrect. The correct answer is ${q.answer}`);
                }

                // Update the score display (the UI element lives in the controls)
                const scoreEl = document.getElementById('score');
                if (scoreEl) scoreEl.textContent = `Score: ${this.score}/${this.attempts}`;

                // Auto‑advance after a short pause
                setTimeout(() => this.nextQuestion(), 2000);
            },

            /* ---------------------------------------------------------
               Navigation (next / previous / restart / toggleIncorrectOnly)
               --------------------------------------------------------- */
            nextQuestion() {
                const filtered = this.getFilteredQuestions();
                if (filtered.length === 0) {
                    this.render();
                    return;
                }
                this.currentQuestion = (this.currentQuestion + 1) % filtered.length;
                this.render();
            },

            previousQuestion() {
                const filtered = this.getFilteredQuestions();
                if (filtered.length === 0) {
                    this.render();
                    return;
                }
                this.currentQuestion =
                    (this.currentQuestion - 1 + filtered.length) % filtered.length;
                this.render();
            },

            restart() {
                this.data.forEach(q => {
                    q.attempted = false;
                    q.correct = false;
                });
                this.currentQuestion = 0;
                this.score = 0;
                this.attempts = 0;
                this.render();

                const scoreEl = document.getElementById('score');
                if (scoreEl) scoreEl.textContent = `Score: ${this.score}/${this.attempts}`;

                ScreenReader.announce('Quiz reset. Starting over.');
            },

            toggleIncorrectOnly(flag) {
                this.incorrectOnly = flag;
                this.currentQuestion = 0;
                this.render();
                ScreenReader.announce(flag ?
                    'Showing only incorrect questions' :
                    'Showing all questions');
            },

            /* ---------------------------------------------------------
               Click‑to‑speak helpers (question & answers)
               --------------------------------------------------------- */
            attachQuizListeners() {
                // Question text
                document.querySelectorAll('.quiz-question').forEach(q => {
                    q.addEventListener('click', () => {
                        const qLang = Storage.load(
                            CONSTANTS.STORAGE_KEYS.QUESTION_LANG,
                            CONSTANTS.DEFAULT_VALUES.QUESTION_LANG
                        );
                        TTSManager.speak(q.textContent.trim(), qLang);
                    });
                });

                // Answer options
                document.querySelectorAll('.quiz-option').forEach(opt => {
                    opt.addEventListener('click', () => {
                        const aLang = Storage.load(
                            CONSTANTS.STORAGE_KEYS.ANSWER_LANG,
                            CONSTANTS.DEFAULT_VALUES.ANSWER_LANG
                        );
                        TTSManager.speak(opt.textContent.trim(), aLang);
                    });
                });
            }
        };

        /* =========================================================
           END OF QUIZ SYSTEM
           ========================================================= */

        /* =========================================================
           QUIZ UI – create the control panel (score, toggle, buttons)
           ========================================================= */

        function renderQuizControls() {
            const controls = document.getElementById('quizControls');
            if (!controls) return;

            controls.innerHTML = `
        <div id="score" class="quiz-score">Score: 0 / 0</div>

        <label id="incorrectOnlyContainer" class="quiz-checkbox">
            <input type="checkbox" id="incorrectOnly">
            Incorrect Only
        </label>

        <button id="nextQuestionBtn" class="touch-target">Next Question</button>
        <button id="restartQuizBtn" class="touch-target">Restart Quiz</button>
    `;

            // Bind the control buttons
            document.getElementById('nextQuestionBtn')
                .addEventListener('click', () => QuizSystem.nextQuestion());

            document.getElementById('restartQuizBtn')
                .addEventListener('click', () => QuizSystem.restart());

            document.getElementById('incorrectOnly')
                .addEventListener('change', (e) => QuizSystem.toggleIncorrectOnly(e.target.checked));
        }

        /* ---------------------------------------------------------
           INITIALISE QUIZ ON PAGE LOAD
           --------------------------------------------------------- */
        function initialiseQuiz() {
            // 1️⃣  Ensure default languages are stored (English Q, Thai A)
            if (!Storage.load(CONSTANTS.STORAGE_KEYS.QUESTION_LANG)) {
                Storage.save(CONSTANTS.STORAGE_KEYS.QUESTION_LANG, 'en-US');
            }
            if (!Storage.load(CONSTANTS.STORAGE_KEYS.ANSWER_LANG)) {
                Storage.save(CONSTANTS.STORAGE_KEYS.ANSWER_LANG, 'th-TH');
            }

            // 2️⃣  Render the static controls (score, buttons, toggle)
            renderQuizControls();

            // 3️⃣  When an example is loaded, build the quiz from it.
            //     Hook into the existing `AppController.loadExample` flow.
            const originalLoadExample = AppController.loadExample;
            AppController.loadExample = async function () {
                await originalLoadExample.apply(this, arguments);
                const example = AppState.getCurrentExample();
                if (example && example.length > 0) {
                    QuizSystem.buildFromExample(example);
                }
            };
        }

        /* ---------------------------------------------------------
           Run the init function once the SPA is ready
           --------------------------------------------------------- */
        document.addEventListener('DOMContentLoaded', () => {
            initialiseQuiz();
        });
        /*=== PATCH END ===*/

        /* Call after each quiz render */
        /*
        QuizSystem.renderCurrentQuestion = function () {
            // ... existing rendering logic ...

            // AFTER the HTML for the question/options is inserted:
            attachQuizListeners();
        };
       
       */ /*=== PATCH END ===*/


        /* -------------------------------------------------------------
           NavigationController – handles topic / title / example selection
           and the forward / backward arrows.
           ------------------------------------------------------------- */
        const NavigationController = {
            topicSelect: null,
            titleSelect: null,
            exampleSelect: null,

            // -----------------------------------------------------------------
            // Simple lock to prevent the navigation functions from running
            // twice at the same time (e.g., button click + ArrowRight key).
            // -----------------------------------------------------------------
            navLock: false,

            init(topicSelect, titleSelect, exampleSelect) {
                this.topicSelect = topicSelect;
                this.titleSelect = titleSelect;
                this.exampleSelect = exampleSelect;

                if (topicSelect) {
                    topicSelect.addEventListener('change', (e) => this.handleTopicChange(e.target.value));
                }
                if (titleSelect) {
                    titleSelect.addEventListener('change', (e) => this.handleTitleChange(+e.target.value));
                }
                // **No change listener for exampleSelect** – we control it manually.
            },

            async handleTopicChange(topicFilename) {
                if (!topicFilename) return;

                try {
                    Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC, topicFilename);
                    await AppController.loadTopic(topicFilename);
                    ScreenReader.announce(`Topic changed to ${topicFilename}`);
                } catch (error) {
                    console.error('Error changing topic:', error);
                    ScreenReader.announce(`Error changing topic: ${error.message}`);
                }
            },

            handleTitleChange(titleIndex) {
                AppState.currentTitle = titleIndex;
                AppController.populateExamples();

                // After repopulating the example list, load the first example of the new title
                AppState.currentExample = 0;
                AppController.loadExample();

                // Sync the UI <select> to the first example (index 0)
                if (this.exampleSelect) {
                    this.exampleSelect.selectedIndex = 0;
                }

                ScreenReader.announce(`Title changed to ${titleIndex + 1}`);
            },

            /** -------------------------------------------------------------
             *  Move to the **next** example.
             *  • Updates AppState only once.
             *  • Loads the new example immediately.
             *  • Afterwards synchronises the <select> UI (without firing a change event).
             *  ------------------------------------------------------------- */
            nextExample() {
                if (this.navLock) return;               // Prevent re‑entry
                this.navLock = true;

                const currentTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                const maxExamples = currentTitle?.examples?.length || 0;

                // ---------------------------------------------------------
                // CASE 1 – Still inside the current title
                // ---------------------------------------------------------
                if (AppState.currentExample < maxExamples - 1) {
                    // ONE increment ONLY
                    AppState.currentExample++;

                    // Load the new example first
                    AppController.loadExample();

                    // THEN update the <select> UI (no change event is fired)
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = AppState.currentExample;
                    }

                    // Release lock after the UI has settled
                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 2 – At the last example of the current title → go to next title
                // ---------------------------------------------------------
                const maxTitles = AppState.currentTopic?.titles?.length || 0;
                if (AppState.currentTitle < maxTitles - 1) {
                    // Move to next title and start at its first example
                    AppState.currentTitle++;
                    AppState.currentExample = 0;

                    // Update title <select>
                    if (this.titleSelect) {
                        this.titleSelect.selectedIndex = AppState.currentTitle;
                    }

                    // Re‑populate examples for the new title and load the first one
                    AppController.populateExamples();
                    AppController.loadExample();

                    // Sync example <select> to the first example (index 0)
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = 0;
                    }

                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 3 – Last title AND last example → wrap to the very first
                // ---------------------------------------------------------
                AppState.currentTitle = 0;
                AppState.currentExample = 0;

                // Update title <select> to first title
                if (this.titleSelect) {
                    this.titleSelect.selectedIndex = 0;
                }

                // Re‑populate examples for the first title and load its first example
                AppController.populateExamples();
                AppController.loadExample();

                // Sync example <select> to first example
                if (this.exampleSelect) {
                    this.exampleSelect.selectedIndex = 0;
                }

                setTimeout(() => { this.navLock = false; }, 0);
            },

            /** -------------------------------------------------------------
             *  Move to the **previous** example.
             *  Mirrors the logic of `nextExample` but in reverse.
             *  ------------------------------------------------------------- */
            previousExample() {
                if (this.navLock) return;               // Prevent re‑entry
                this.navLock = true;

                // ---------------------------------------------------------
                // CASE 1 – Still inside the current title (not the first example)
                // ---------------------------------------------------------
                if (AppState.currentExample > 0) {
                    // ONE decrement ONLY
                    AppState.currentExample--;

                    // Load the new example first
                    AppController.loadExample();

                    // THEN update the <select> UI (no change event is fired)
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = AppState.currentExample;
                    }

                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 2 – At the first example of the current title → go to previous title
                // ---------------------------------------------------------
                if (AppState.currentTitle > 0) {
                    // Move to previous title
                    AppState.currentTitle--;

                    const prevTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                    AppState.currentExample = (prevTitle?.examples?.length || 1) - 1; // last example of that title

                    // Update title <select>
                    if (this.titleSelect) {
                        this.titleSelect.selectedIndex = AppState.currentTitle;
                    }

                    // Re‑populate examples for the new title and load the last example
                    AppController.populateExamples();
                    AppController.loadExample();

                    // Sync example <select> to the last example of the new title
                    if (this.exampleSelect) {
                        this.exampleSelect.selectedIndex = AppState.currentExample;
                    }

                    setTimeout(() => { this.navLock = false; }, 0);
                    return;
                }

                // ---------------------------------------------------------
                // CASE 3 – First title AND first example → wrap to the very last
                // ---------------------------------------------------------
                const maxTitles = AppState.currentTopic?.titles?.length || 0;
                AppState.currentTitle = maxTitles - 1;        // last title
                const lastTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                AppState.currentExample = (lastTitle?.examples?.length || 1) - 1; // last example of last title

                // Update title <select> to last title
                if (this.titleSelect) {
                    this.titleSelect.selectedIndex = AppState.currentTitle;
                }

                // Re‑populate examples for the last title and load its last example
                AppController.populateExamples();
                AppController.loadExample();

                // Sync example <select> to the last example
                if (this.exampleSelect) {
                    this.exampleSelect.selectedIndex = AppState.currentExample;
                }

                setTimeout(() => { this.navLock = false; }, 0);
            }
        };

        // ========== KEYBOARD SHORTCUT MANAGER ==========
        const KeyboardManager = {
            init() {
                document.addEventListener('keydown', this.handleKeydown.bind(this));
            },

            handleKeydown(event) {
                // Don't trigger shortcuts when user is typing in inputs
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                switch (event.key) {
                    case ' ':
                        event.preventDefault();
                        if (AppState.isPlaying) {
                            PlaybackController.pauseExample();
                        } else {
                            PlaybackController.playExample();
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        NavigationController.nextExample();
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        NavigationController.previousExample();
                        break;
                    case 'r':
                    case 'R':
                        event.preventDefault();
                        PlaybackController.restartExample();
                        break;
                    case 'n':
                    case 'N':
                        event.preventDefault();
                        QuizSystem.nextQuestion();
                        break;
                    case 's':
                    case 'S':
                        event.preventDefault();
                        if (!document.getElementById('settingsThaiFont')) {
                            SettingsManager.show();
                        }
                        break;
                    case 'Escape':
                        if (document.getElementById('settingsThaiFont')) {
                            event.preventDefault();
                            SettingsManager.close();
                        }
                        break;
                }
            }
        };

        /* =========================================================
           MAIN APPLICATION CONTROLLER
           ========================================================= */
        const AppController = {

            async initSPA() {
                /* ---------- 1️⃣  Inject the generated HTML ---------- */
                const contentArea = document.getElementById('contentArea');
                const controlsArea = document.getElementById('controlsArea');

                if (contentArea) {
                    // Insert the full UI (topic selector, language grid, example,
                    // quiz, etc.) that is produced by getMainHTML().
                    contentArea.innerHTML = this.getMainHTML();
                }

                if (controlsArea) {
                    // At the moment getControlsHTML() returns an empty string,
                    // but we keep the call here for future extensions.
                    controlsArea.innerHTML = this.getControlsHTML();
                }

                /* ---------- 2️⃣  Continue with normal initialisation ---------- */
                // Initialise all managers and components
                ThemeManager.init();
                FontManager.init();
                TTSManager.initialize();
                KeyboardManager.init();

                // Initialise AppState
                AppState.initialize();

                // Load configuration (languages, features, etc.)
                await AppConfig.load();

                // Initialise language manager after config is loaded
                LanguageManager.init();

                // Initialise example renderer (needs the #exampleDisplay element)
                const exampleDisplay = document.getElementById('exampleDisplay');
                if (exampleDisplay) {
                    ExampleRenderer.init(exampleDisplay);
                }

                // Load topics and set up navigation UI
                await this.loadTopics();
                this.bindUIElements();

                // Load the first example (or the saved one)
                this.loadExample();

                // Announce that the app is ready
                ScreenReader.announce('Application initialized successfully');
            },

            /* =========================================================
               MAIN HTML TEMPLATE (generated by the SPA)
               ========================================================= */
            getMainHTML() {
                return `
        <div class="selection-header">Text To Speech</div>

        <!-- Progress Bar -->
        <div style="margin: 0.5em 0;">
            <div class="progress-bar">
                <div id="progressBar" class="progress-fill" style="width: 0%"></div>
            </div>
        </div>

        <details class="topic-options-details" id="topicOptionsDetails">
            <summary>Topic & Language Options</summary>
            <div class="topic-options-content">
                <div id="topicSelectionControls" class="topic-selection-controls">
                    <label>Topic: <select id="topicSelect" aria-label="Select topic"></select></label>
                    <label>Title: <select id="titleSelect" aria-label="Select title"></select></label>
                    <label>Example: <select id="exampleSelect" aria-label="Select example"></select></label>
                </div>

                <!-- ***** LANGUAGE CONTROLS ***** -->
                <div class="language-controls" id="languageControls">
                    <details>
                        <summary style="font-weight: bold;">Language Options</summary>
                        <div class="language-controls-content">
                            <!-- Dynamic Language Grid -->
                            <div class="language-controls-grid">
                                <div class="language-grid">
                                    <div class="language-grid-header">Language</div>
                                    <div class="language-grid-header">Display</div>
                                    <div class="language-grid-header">Speak</div>
                                    <!-- Language rows will be dynamically inserted here -->
                                </div>
                            </div>

                            <!-- Playback Delay -->
                            <div class="language-delay-row">
                                <span class="delay-label">Reading delay (secs)</span>
                                <input type="number" id="playbackDelay" min="0.5" max="5" step="0.1" value="0.5">
                            </div>
                        </div>
                    </details>
                </div>
                <!-- ***** END LANGUAGE CONTROLS ***** -->

            </div>
        </details>

        <section id="exampleSec">
            <div id="exampleDisplay" aria-live="polite"></div>
            <div id="exampleControls" class="controls">
                <div class="example-controls-row">
                    <button id="playBtn" aria-label="Play example" class="touch-target">▶️</button>
                    <button id="pauseBtn" aria-label="Pause example" class="touch-target">⏸️</button>
                    <button id="restartBtn" aria-label="Restart example" class="touch-target">⏮️</button>
                    <div class="example-number-container">
                        <span class="example-number-label">Example</span>
                        <span id="currentExampleNumber" class="example-number">1</span>
                    </div>
                    <button id="prevExample" aria-label="Previous example" class="touch-target">⬅️</button>
                    <button id="nextExample" aria-label="Next example" class="touch-target">➡️</button>
                </div>
            </div>
        </section>

        <section id="quizSec">
            <h3>Practice Quiz</h3>

            <div id="quiz" aria-live="polite"></div>

            <!-- Quiz Controls (same layout as example controls) -->
            <div id="quizControls" class="quiz-controls">
                <div id="score" class="quiz-score">Score: 0 / 0</div>

                <label id="incorrectOnlyContainer" class="quiz-checkbox">
                    <input type="checkbox" id="incorrectOnly">
                    Incorrect Only
                </label>

                <details class="quiz-language-options" open>
                    <summary class="quiz-language-summary">Language Options</summary>
                    <div class="quiz-language-content">
                        <div id="questionLangGroup" class="lang-option"></div>
                        <div id="answerLangGroup" class="lang-option"></div>
                    </div>
                </details>

                <button id="nextQuestionBtn" class="touch-target">Next Question</button>
                <button id="restartQuizBtn" class="touch-target">Restart Quiz</button>
            </div>
        </section>`;
            },

            getControlsHTML() {
                return ''; // Controls are handled by individual components
            },

            bindUIElements() {
                // Get navigation elements
                const topicSelect = document.getElementById('topicSelect');
                const titleSelect = document.getElementById('titleSelect');
                const exampleSelect = document.getElementById('exampleSelect');

                // Initialize navigation controller
                NavigationController.init(topicSelect, titleSelect, exampleSelect);

                // Bind playback controls
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const restartBtn = document.getElementById('restartBtn');
                const prevExample = document.getElementById('prevExample');
                const nextExample = document.getElementById('nextExample');

                if (playBtn) playBtn.addEventListener('click', () => PlaybackController.playExample());
                if (pauseBtn) pauseBtn.addEventListener('click', () => PlaybackController.pauseExample());
                if (restartBtn) restartBtn.addEventListener('click', () => PlaybackController.restartExample());
                if (prevExample) prevExample.addEventListener('click', () => NavigationController.previousExample());
                if (nextExample) nextExample.addEventListener('click', () => NavigationController.nextExample());

                // Bind quiz controls
                const prevQ = document.getElementById('prevQ');
                const nextQ = document.getElementById('nextQ');
                const retryQuiz = document.getElementById('retryQuiz');
                const incorrectOnly = document.getElementById('incorrectOnly');

                if (prevQ) prevQ.addEventListener('click', () => QuizSystem.previousQuestion());
                if (nextQ) nextQ.addEventListener('click', () => QuizSystem.nextQuestion());
                if (retryQuiz) retryQuiz.addEventListener('click', () => QuizSystem.retry());
                if (incorrectOnly) incorrectOnly.addEventListener('change', (e) => QuizSystem.toggleIncorrectOnly(e.target.checked));

                // Bind settings button
                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', () => SettingsManager.show());
                }

                // Bind playback delay
                const playbackDelay = document.getElementById('playbackDelay');
                if (playbackDelay) {
                    playbackDelay.value = Storage.load(CONSTANTS.STORAGE_KEYS.PLAYBACK_DELAY, CONSTANTS.DEFAULT_VALUES.PLAYBACK_DELAY);
                    playbackDelay.addEventListener('change', (e) => {
                        Storage.save(CONSTANTS.STORAGE_KEYS.PLAYBACK_DELAY, e.target.value);
                    });
                }
            },

            async loadTopics() {
                try {
                    const topics = await TopicManager.loadTopicList();
                    AppState.topics = topics;
                    this.populateTopicSelect();

                    // Load the saved or first topic
                    const savedTopic = Storage.load(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC);
                    const topicToLoad = savedTopic || (topics.length > 0 ? topics[0].topicFilename : '');

                    if (topicToLoad) {
                        await this.loadTopic(topicToLoad);
                    }
                } catch (error) {
                    console.error('Error loading topics:', error);
                    ErrorHandler.showErrorToUser('Failed to load topics. Please check your connection.');
                }
            },

            populateTopicSelect() {
                const topicSelect = document.getElementById('topicSelect');
                if (!topicSelect) return;

                topicSelect.innerHTML = '';
                AppState.topics.forEach((topic, index) => {
                    const option = document.createElement('option');
                    option.value = topic.topicFilename;
                    option.textContent = topic.topic;
                    topicSelect.appendChild(option);
                });

                // Set the current topic
                if (AppState.currentTopic?.topicFilename) {
                    topicSelect.value = AppState.currentTopic.topicFilename;
                }
            },

            async loadTopic(topicFilename) {
                try {
                    const topicData = await TopicManager.loadTopic(topicFilename);
                    AppState.currentTopic = topicData;
                    AppState.currentTitle = 0;
                    AppState.currentExample = 0;

                    this.populateTitles();
                    this.populateExamples();
                    this.loadExample();

                    Storage.save(CONSTANTS.STORAGE_KEYS.CURRENT_TOPIC, topicFilename);
                } catch (error) {
                    console.error('Error loading topic:', error);
                    ErrorHandler.showErrorToUser(`Failed to load topic: ${error.message}`);
                }
            },

            populateTitles() {
                const titleSelect = document.getElementById('titleSelect');
                if (!titleSelect || !AppState.currentTopic) return;

                titleSelect.innerHTML = '';
                AppState.currentTopic.titles.forEach((title, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = title.title || `Title ${index + 1}`;
                    titleSelect.appendChild(option);
                });

                titleSelect.value = AppState.currentTitle;
            },

            populateExamples() {
                const exampleSelect = document.getElementById('exampleSelect');
                if (!exampleSelect || !AppState.currentTopic) return;

                const currentTitle = AppState.currentTopic.titles[AppState.currentTitle];
                if (!currentTitle) return;

                exampleSelect.innerHTML = '';
                const examples = currentTitle.examples || [];

                examples.forEach((example, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Example ${index + 1}`;
                    exampleSelect.appendChild(option);
                });

                exampleSelect.value = AppState.currentExample;
            },

            loadExample() {
                AppState.saveNavigation();
                this.renderExample();

                AppState.currentWordIndex = 0;
                AppState.isPlaying = false;
                TTSManager.cancel();

                this.updateExampleNumber();
                this.updateProgressBar();

                // Ensure quiz language options are refreshed
                setTimeout(() => {
                    LanguageManager.renderQuizLanguageOptions();
                    this.ensureTopicSelectionVisible();
                }, 200);
            },

            renderExample() {
                const currentTitle = AppState.currentTopic?.titles?.[AppState.currentTitle];
                const examples = currentTitle?.examples;
                const example = examples?.[AppState.currentExample] || [];
                ExampleRenderer.render(example);
                QuizSystem.buildFromExample(example);
            },

            updateExampleNumber() {
                const currentExampleNumber = document.getElementById('currentExampleNumber');
                if (currentExampleNumber) {
                    currentExampleNumber.textContent = AppState.currentExample + 1;
                }
            },

            updateProgressBar() {
                const progressBar = document.getElementById('progressBar');
                if (!progressBar || !AppState.currentTopic) return;

                const percentage = ProgressTracker.getCompletionPercentage(
                    AppState.currentTopic.topicFilename,
                    AppState.currentTopic
                );
                progressBar.style.width = `${percentage}%`;
            },

            ensureTopicSelectionVisible() {
                const topicOptionsDetails = document.getElementById('topicOptionsDetails');
                if (topicOptionsDetails && !topicOptionsDetails.open) {
                    topicOptionsDetails.open = true;
                }
            },

            restoreSettings() {
                // Restore any settings that need to be applied
                FontManager.apply();

                // Re-initialize navigation
                const topicSelect = document.getElementById('topicSelect');
                const titleSelect = document.getElementById('titleSelect');
                const exampleSelect = document.getElementById('exampleSelect');
                NavigationController.init(topicSelect, titleSelect, exampleSelect);
            }
        };

        /* -------------------------------------------------------------
           Run the init function once the SPA is ready
           ------------------------------------------------------------- */
        document.addEventListener('DOMContentLoaded', () => {
            // Initialise the SPA (inject UI, set up managers, load first example)
            AppController.initSPA();
        });

    </script>


</body>

</html>