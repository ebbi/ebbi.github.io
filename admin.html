<!-- thai-json-generator-v2.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thai Learning App - v2 Data Model Generator</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            --primary: #2563eb;
            --primary-light: #60a5fa;
            --primary-dark: #1d4ed8;
            --secondary: #7c3aed;
            --bg: #ffffff;
            --text: #1a1a1a;
            --card: #f8fafc;
            --border: #e2e8f0;
            --success: #059669;
            --warning: #d97706;
            --error: #dc2626;
            --code-bg: #1e1e1e;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 30px;
            border-radius: 16px;
            margin-bottom: 30px;
        }

        /* Two Column Layout */
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
        }

        .panel h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Session Buttons */
        .session-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .session-btn {
            padding: 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.2s;
            text-align: left;
        }

        .session-btn .material-icons {
            font-size: 32px;
        }

        .session-btn.init {
            background: var(--secondary);
            color: white;
        }

        .session-btn.load {
            background: var(--primary);
            color: white;
        }

        .session-btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }

        /* Import/Export */
        .import-section textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
            margin: 15px 0;
        }

        .file-input-wrapper {
            display: flex;
            gap: 10px;
        }

        .file-input-wrapper .btn {
            flex: 1;
        }

        /* Vocabulary Status */
        .vocab-status {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-grid {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .status-item {
            flex: 1;
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .status-number {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
        }

        .status-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Radio Selection */
        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .radio-card {
            flex: 1;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-card.selected {
            border-color: var(--primary);
            background: rgba(37, 99, 235, 0.05);
        }

        .radio-card .material-icons {
            font-size: 32px;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .radio-card h4 {
            margin-bottom: 5px;
        }

        .radio-card small {
            color: var(--text-secondary);
        }

        /* Thai Input */
        .input-section {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        #thaiInput {
            width: 100%;
            min-height: 200px;
            padding: 20px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-family: 'Noto Sans Thai', 'Courier New', monospace;
            font-size: 1.8rem;
            line-height: 2.2rem;
            background: var(--bg);
            resize: vertical;
            margin: 15px 0;
        }

        .input-stats {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .instruction-box {
            background: rgba(37, 99, 235, 0.05);
            border-left: 4px solid var(--primary);
            padding: 15px;
            border-radius: 4px;
        }

        /* Generate Button */
        .generate-section {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .generate-button {
            width: 100%;
            padding: 20px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.2s;
        }

        .generate-button:hover {
            filter: brightness(1.1);
            transform: translateY(-2px);
        }

        .generated-blocks {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .block-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
        }

        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border);
        }

        .block-type {
            background: var(--primary-light);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }

        /* Preview */
        .preview-section {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .preview-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preview-tab {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 20px;
            cursor: pointer;
            background: var(--bg);
            white-space: nowrap;
        }

        .preview-tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .json-viewer {
            max-height: 500px;
            overflow-y: auto;
            background: var(--code-bg);
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', monospace;
            font-size: 13px;
            color: #d4d4d4;
            white-space: pre-wrap;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn-outline:hover {
            background: var(--bg);
            border-color: var(--primary);
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .status-badge {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-complete {
            background: var(--success);
        }

        .status-warning {
            background: var(--warning);
        }

        .duplicate-warning {
            background: rgba(217, 119, 6, 0.1);
            border-left: 4px solid var(--warning);
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .tag {
            background: var(--primary-light);
            color: white;
            padding: 4px 10px;
            border-radius: 16px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üìù Thai Learning App - v2 Data Model Generator</h1>
            <p>Build vocabulary incrementally | Words are space-separated, sentences are newline-separated</p>
        </div>

        <!-- Document Metadata -->
        <div class="panel" style="margin-bottom: 20px;">
            <h3>üìã Document Metadata</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Document ID</label>
                    <input type="text" id="docId" value="ls1"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px;">
                </div>
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Version</label>
                    <input type="text" id="version" value="1.0.0"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px;">
                </div>
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Difficulty</label>
                    <select id="difficulty"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px;">
                        <option value="1">1 - Beginner</option>
                        <option value="2" selected>2 - Elementary</option>
                        <option value="3">3 - Intermediate</option>
                        <option value="4">4 - Upper Intermediate</option>
                        <option value="5">5 - Advanced</option>
                    </select>
                </div>
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Authors</label>
                    <input type="text" id="authors" value="author1, author2"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px;">
                </div>
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Reviewers</label>
                    <input type="text" id="reviewers" value="reviewer1"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px;">
                </div>
                <div>
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Prerequisites</label>
                    <input type="text" id="prerequisites" value="thai-basics-1"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 6px;">
                </div>
                <div style="grid-column: span 2;">
                    <label style="display: block; font-weight: 600; margin-bottom: 5px;">Tags</label>
                    <div class="tags-input"
                        style="display: flex; flex-wrap: wrap; gap: 8px; padding: 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg);"
                        id="tagsContainer">
                        <input type="text" id="newTag" placeholder="Add tag and press Enter..."
                            style="border: none; outline: none; flex: 1;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Two Column: Session Workflow and Import/Export -->
        <div class="two-column">
            <!-- Left Column: Session Workflow -->
            <div class="panel">
                <h3><span class="material-icons">timeline</span> Session Workflow</h3>
                <div class="session-buttons">
                    <button class="session-btn init" onclick="initializeNewDocument()">
                        <span class="material-icons">fiber_new</span>
                        <div>
                            <strong>Initialize New Document</strong><br>
                            <small>Creates new document with current metadata only</small>
                        </div>
                    </button>
                    <button class="session-btn load" onclick="importDocument()">
                        <span class="material-icons">upload_file</span>
                        <div>
                            <strong>Import Document</strong><br>
                            <small>Loads existing document and caches vocabulary</small>
                        </div>
                    </button>
                </div>
            </div>

            <!-- Right Column: Import/Export -->
            <div class="panel">
                <h3><span class="material-icons">import_export</span> Import/Export Document</h3>
                <div class="import-section">
                    <textarea id="importJson" placeholder="Document JSON will appear here..."></textarea>
                    <div class="file-input-wrapper">
                        <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadFile()">
                        <button class="btn btn-outline" onclick="document.getElementById('fileInput').click()">
                            <span class="material-icons">folder_open</span> Upload JSON
                        </button>
                        <button class="btn btn-outline" onclick="copyToClipboard()">
                            <span class="material-icons">content_copy</span> Copy
                        </button>
                        <button class="btn btn-outline" onclick="clearImport()">
                            <span class="material-icons">clear</span> Clear
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Vocabulary Status -->
        <div class="vocab-status">
            <h3>üìö Vocabulary Status</h3>
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-number" id="mainVocabCount">0</div>
                    <div class="status-label">Main Vocabulary (Words Only)</div>
                </div>
                <div class="status-item">
                    <div class="status-number" id="cachedCount">0</div>
                    <div class="status-label">Cached New Words</div>
                </div>
            </div>
            <div id="duplicateWarning" class="duplicate-warning" style="display: none;">
                <span class="material-icons">warning</span>
                <span id="duplicateMessage"></span>
            </div>
        </div>

        <!-- Input Configuration - Radio Selection -->
        <div class="panel" style="margin-bottom: 20px;">
            <h3>‚öôÔ∏è Input Configuration</h3>
            <div class="radio-group">
                <div class="radio-card" id="radioWord" onclick="setDataType('word')">
                    <span class="material-icons">grid_view</span>
                    <h4>Word List</h4>
                    <small>space between words</small>
                </div>
                <div class="radio-card" id="radioParagraph" onclick="setDataType('paragraph')">
                    <span class="material-icons">chat</span>
                    <h4>Paragraph</h4>
                    <small>new lines between sentences, spaces between words</small>
                </div>
            </div>
        </div>

        <!-- Thai Input -->
        <div class="input-section">
            <h3>üìù Enter New Thai Text</h3>
            <div class="instruction-box">
                <span class="material-icons">info</span>
                <span id="instructionText">Separate words with space. Example: ‡∏Å‡∏¥‡∏ô ‡∏î‡∏∑‡πà‡∏° ‡∏î‡∏π ‡∏ü‡∏±‡∏á ‡∏ï‡∏∑‡πà‡∏ô</span>
            </div>
            <textarea id="thaiInput" placeholder="‡∏Å‡∏¥‡∏ô ‡∏î‡∏∑‡πà‡∏° ‡∏î‡∏π ‡∏ü‡∏±‡∏á ‡∏ï‡∏∑‡πà‡∏ô"></textarea>
            <div class="input-stats">
                <span><span class="material-icons">abc</span> Words: <span id="wordCount">0</span></span>
                <span><span class="material-icons">sentence</span> Sentences: <span id="sentenceCount">0</span></span>
                <span><span class="material-icons">cleaning_services</span> <button class="btn btn-outline"
                        style="padding: 5px 10px;" onclick="cleanText()">Clean Text</button></span>
                <span><span class="material-icons">sync</span> <button class="btn btn-outline"
                        style="padding: 5px 10px;" onclick="checkDuplicates()">Check Duplicates</button></span>
            </div>
        </div>

        <!-- Generate Section -->
        <div class="generate-section">
            <button class="generate-button" onclick="generateBlock()">
                <span class="material-icons">auto_awesome</span>
                Generate New Block from Input
            </button>
            <div id="generatedBlocks" class="generated-blocks"></div>
        </div>

        <!-- Preview -->
        <div class="preview-section">
            <div class="preview-header">
                <h3>üëÅÔ∏è Preview</h3>
                <div class="preview-tabs">
                    <div class="preview-tab active" onclick="switchPreview('full')">Full Document</div>
                    <div class="preview-tab" onclick="switchPreview('blocks')">Blocks Only (JSON)</div>
                    <div class="preview-tab" onclick="switchPreview('vocab')">Main Vocabulary</div>
                    <div class="preview-tab" onclick="switchPreview('cache')">Cache Vocabulary</div>
                </div>
            </div>
            <div id="jsonViewer" class="json-viewer"></div>
            <div class="action-buttons">
                <button class="btn btn-success" onclick="downloadJSON('full')">
                    <span class="material-icons">download</span> Download Full
                </button>
                <button class="btn btn-outline" onclick="downloadJSON('blocks')">
                    <span class="material-icons">download</span> Download Block
                </button>
                <button class="btn btn-outline" onclick="copyPreview()">
                    <span class="material-icons">content_copy</span> Copy Preview
                </button>
                <button class="btn btn-outline" onclick="clearPreview()">
                    <span class="material-icons">clear</span> Clear Preview
                </button>
                <button class="btn btn-warning" onclick="updateVocabulary()">
                    <span class="material-icons">save</span> Update Vocabulary
                </button>
            </div>
        </div>
    </div>

    <script>
        // Translation API
        const TranslationAPI = {
            cache: JSON.parse(localStorage.getItem('translationCache_v2') || '{}'),

            async translate(text, targetLang) {
                if (!text || text.trim() === '') return '';
                const cacheKey = `${text}_${targetLang}`;
                if (this.cache[cacheKey]) return this.cache[cacheKey];

                try {
                    const response = await fetch(
                        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=th|${targetLang}`
                    );
                    const data = await response.json();
                    if (data.responseStatus === 200) {
                        const translation = data.responseData.translatedText;
                        this.cache[cacheKey] = translation;
                        localStorage.setItem('translationCache_v2', JSON.stringify(this.cache));
                        return translation;
                    }
                } catch (e) {
                    console.warn('Translation failed:', e);
                }
                return '';
            }
        };

        // Text Cleaner - Keep only Thai characters
        const Cleaner = {
            clean(text) {
                if (!text) return text;
                // Keep only Thai characters, spaces, and newlines
                let cleaned = text.replace(/[^\u0E00-\u0E7F\s\n]/g, '');
                // Clean up whitespace
                cleaned = cleaned
                    .replace(/[^\S\n]+/g, ' ')
                    .replace(/^\s+/gm, '')
                    .replace(/\s+$/gm, '')
                    .replace(/\n\s+\n/g, '\n\n')
                    .replace(/\n{3,}/g, '\n\n');
                return cleaned.trim();
            }
        };

        // App State
        const AppState = {
            dataType: 'word',
            languages: [
                { code: 'en', name: 'English', flag: 'üá¨üáß', selected: true },
                { code: 'fa', name: 'Farsi', flag: 'üáÆüá∑', selected: true }
            ],
            mainVocabulary: {},
            cacheVocabulary: {},
            blocks: []
        };

        // Initialize
        function init() {
            setDataType('word');
            updateStats();
            updateCacheDisplay();
            showFullDocument();

            // Add event listener for tags
            document.getElementById('newTag').addEventListener('keypress', handleTagKeyPress);
        }

        // ==================== SESSION WORKFLOW ====================

        function initializeNewDocument() {
            if (confirm('Start a new document? Current unsaved data will be cleared.')) {
                AppState.mainVocabulary = {};
                AppState.cacheVocabulary = {};
                AppState.blocks = [];

                const newDoc = buildFullDocument();
                document.getElementById('importJson').value = JSON.stringify(newDoc, null, 2);

                updateCacheDisplay();
                showFullDocument();
                updateBlocksDisplay();
            }
        }

        function importDocument() {
            try {
                const jsonText = document.getElementById('importJson').value;
                if (!jsonText.trim()) {
                    alert('Please paste JSON or upload a file first');
                    return;
                }

                const data = JSON.parse(jsonText);

                if (!data.documentId) throw new Error('Missing documentId');

                // Load metadata
                document.getElementById('docId').value = data.documentId;
                document.getElementById('version').value = data.metadata?.version || '1.0.0';
                document.getElementById('difficulty').value = data.metadata?.difficulty || 2;
                document.getElementById('authors').value = (data.metadata?.authors || ['author1']).join(', ');
                document.getElementById('reviewers').value = (data.metadata?.reviewers || ['reviewer1']).join(', ');
                document.getElementById('prerequisites').value = (data.metadata?.prerequisites || []).join(', ');

                // Load tags
                document.getElementById('tagsContainer').innerHTML = '<input type="text" id="newTag" placeholder="Add tag and press Enter..." style="border: none; outline: none; flex: 1;">';
                document.getElementById('newTag').addEventListener('keypress', handleTagKeyPress);
                if (data.metadata?.tags) {
                    data.metadata.tags.forEach(tag => addTag(tag));
                }

                // Load main vocabulary
                if (data.vocabulary) {
                    AppState.mainVocabulary = data.vocabulary;
                }

                // Load existing blocks
                if (data.sections && data.sections[0]?.content) {
                    AppState.blocks = data.sections[0].content;
                }

                // Clear cache
                AppState.cacheVocabulary = {};

                updateCacheDisplay();
                showFullDocument();
                updateBlocksDisplay();
                alert('Document imported successfully!');

            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        // ==================== BLOCK GENERATION ====================

        async function generateBlock() {
            const text = document.getElementById('thaiInput').value;
            if (!text.trim()) {
                alert('Please enter some Thai text');
                return;
            }

            const selectedLangs = AppState.languages.filter(l => l.selected).map(l => l.code);
            if (selectedLangs.length === 0) {
                alert('Please select at least one target language');
                return;
            }

            if (AppState.dataType === 'word') {
                await generateWordBlock(text, selectedLangs);
            } else {
                await generateParagraphBlock(text, selectedLangs);
            }

            updateCacheDisplay();
            updateBlocksDisplay();
            showBlocksOnly();
        }

        async function generateWordBlock(text, selectedLangs) {
            const words = text.split(/\s+/).filter(w => w.trim().length > 0);
            if (words.length === 0) return;

            // Remove duplicates
            const uniqueWords = [...new Set(words)];

            // Cache ONLY words (not sentences)
            for (const word of uniqueWords) {
                if (!AppState.mainVocabulary[word] && !AppState.cacheVocabulary[word]) {
                    AppState.cacheVocabulary[word] = {
                        translations: {}
                    };
                    for (const lang of selectedLangs) {
                        AppState.cacheVocabulary[word].translations[lang] = await TranslationAPI.translate(word, lang);
                    }
                }
            }

            // Create word list block
            const newBlock = {
                type: 'words',
                config: {
                    heading: {
                        en: 'Vocabulary List',
                        fa: 'ŸÑ€åÿ≥ÿ™ Ÿàÿß⁄ò⁄ØÿßŸÜ',
                        th: '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå'
                    },
                    activity: {
                        inherit: true
                    }
                },
                wordIds: uniqueWords
            };

            AppState.blocks.push(newBlock);
        }

        async function generateParagraphBlock(text, selectedLangs) {
            // Split by newlines to get sentences
            const sentences = text.split('\n').filter(s => s.trim().length > 0);
            if (sentences.length === 0) return;

            const sentencesData = [];
            const allWords = new Set();

            for (const sentence of sentences) {
                // Split sentence into words by spaces
                const words = sentence.split(/\s+/).filter(w => w.trim().length > 0);

                // Add words to set for vocabulary (words only, not full sentences)
                words.forEach(w => allWords.add(w));

                // Get sentence-level translations
                const translations = {};
                for (const lang of selectedLangs) {
                    translations[lang] = await TranslationAPI.translate(sentence, lang);
                }

                // IMPORTANT: Remove spaces from source to create continuous Thai text
                // Thai sentences don't have spaces between words
                const continuousSource = words.join('');

                sentencesData.push({
                    type: 'sentence',
                    source: continuousSource,  // No spaces!
                    wordIds: words,  // Keep words array for vocabulary reference
                    translations: translations
                });
            }

            // Cache ONLY words (not sentences)
            for (const word of allWords) {
                if (!AppState.mainVocabulary[word] && !AppState.cacheVocabulary[word]) {
                    AppState.cacheVocabulary[word] = {
                        translations: {}
                    };
                    for (const lang of selectedLangs) {
                        AppState.cacheVocabulary[word].translations[lang] = await TranslationAPI.translate(word, lang);
                    }
                }
            }

            // Create paragraph block
            const newBlock = {
                type: 'paragraph',
                config: {
                    heading: {
                        en: 'Conversation Practice',
                        fa: 'ÿ™ŸÖÿ±€åŸÜ ŸÖ⁄©ÿßŸÑŸÖŸá',
                        th: '‡∏ù‡∏∂‡∏Å‡∏™‡∏ô‡∏ó‡∏ô‡∏≤'
                    },
                    grammar: {
                        pattern: '',
                        explanation: {},
                        usage: {},
                        examples: []
                    },
                    activity: {
                        inherit: true
                    }
                },
                sentences: sentencesData
            };

            AppState.blocks.push(newBlock);
        }

        // ==================== VOCABULARY MANAGEMENT ====================

        function updateVocabulary() {
            const cacheSize = Object.keys(AppState.cacheVocabulary).length;
            if (cacheSize === 0) {
                alert('No cached words to update');
                return;
            }

            if (confirm(`Merge ${cacheSize} new word(s) into main vocabulary?`)) {
                Object.assign(AppState.mainVocabulary, AppState.cacheVocabulary);
                AppState.cacheVocabulary = {};
                updateCacheDisplay();
                showFullDocument();
                alert('Vocabulary updated!');
            }
        }

        function checkDuplicates() {
            const text = document.getElementById('thaiInput').value;
            const newWords = new Set();

            if (AppState.dataType === 'word') {
                text.split(/\s+/).filter(w => w.trim()).forEach(w => newWords.add(w));
            } else {
                text.split('\n').filter(s => s.trim()).forEach(s => {
                    s.split(/\s+/).filter(w => w.trim()).forEach(w => newWords.add(w));
                });
            }

            const existing = [];
            const cached = [];
            const trulyNew = [];

            newWords.forEach(word => {
                if (AppState.mainVocabulary[word]) {
                    existing.push(word);
                } else if (AppState.cacheVocabulary[word]) {
                    cached.push(word);
                } else {
                    trulyNew.push(word);
                }
            });

            const warning = document.getElementById('duplicateWarning');
            if (existing.length > 0 || cached.length > 0) {
                warning.style.display = 'block';
                let message = '';
                if (existing.length > 0) message += `üìö Main: ${existing.join(', ')}. `;
                if (cached.length > 0) message += `üíæ Cache: ${cached.join(', ')}. `;
                message += `‚ú® New: ${trulyNew.length}`;
                document.getElementById('duplicateMessage').innerHTML = message;
            } else {
                warning.style.display = 'none';
            }
        }

        // ==================== DISPLAY FUNCTIONS ====================

        function updateCacheDisplay() {
            document.getElementById('mainVocabCount').textContent = Object.keys(AppState.mainVocabulary).length;
            document.getElementById('cachedCount').textContent = Object.keys(AppState.cacheVocabulary).length;
        }

        function updateBlocksDisplay() {
            const container = document.getElementById('generatedBlocks');
            container.innerHTML = '';

            AppState.blocks.forEach((block, index) => {
                const card = document.createElement('div');
                card.className = 'block-card';

                if (block.type === 'words') {
                    card.innerHTML = `
                        <div class="block-header">
                            <span class="block-type">üìö Word List</span>
                            <span class="material-icons" onclick="removeBlock(${index})">close</span>
                        </div>
                        <div><strong>Words:</strong> ${block.wordIds?.length || 0}</div>
                        <div style="margin-top: 10px; font-size: 0.9rem;">${block.wordIds?.slice(0, 5).join(' ¬∑ ')}${block.wordIds?.length > 5 ? '...' : ''}</div>
                    `;
                } else {
                    card.innerHTML = `
                        <div class="block-header">
                            <span class="block-type">üìù Paragraph</span>
                            <span class="material-icons" onclick="removeBlock(${index})">close</span>
                        </div>
                        <div><strong>Sentences:</strong> ${block.sentences?.length || 0}</div>
                        <div style="margin-top: 10px; font-size: 0.9rem;">${block.sentences?.slice(0, 2).map(s => s.source).join('<br>')}${block.sentences?.length > 2 ? '<br>...' : ''}</div>
                    `;
                }
                container.appendChild(card);
            });
        }

        function buildFullDocument() {
            const docId = document.getElementById('docId').value;
            const version = document.getElementById('version').value;
            const difficulty = parseInt(document.getElementById('difficulty').value);
            const authors = document.getElementById('authors').value.split(',').map(s => s.trim()).filter(s => s);
            const reviewers = document.getElementById('reviewers').value.split(',').map(s => s.trim()).filter(s => s);
            const prerequisites = document.getElementById('prerequisites').value.split(',').map(s => s.trim()).filter(s => s);
            const tags = getTags();

            // Activity settings
            const wordTypes = ['multipleChoiceWord', 'flashcardWord'];
            const sentenceTypes = ['multipleChoiceSentence', 'flashcardSentence', 'buildSentence'];

            // Combine main and cache vocabulary
            const combinedVocabulary = { ...AppState.mainVocabulary, ...AppState.cacheVocabulary };

            return {
                documentId: docId,
                metadata: {
                    version: version,
                    created: new Date().toISOString().split('T')[0] + 'T10:00:00Z',
                    updated: new Date().toISOString(),
                    authors: authors.length ? authors : ['author1'],
                    reviewers: reviewers.length ? reviewers : ['reviewer1'],
                    difficulty: difficulty,
                    prerequisites: prerequisites,
                    tags: tags
                },
                vocabulary: combinedVocabulary,
                activitySettings: {
                    words: {
                        enabled: true,
                        types: wordTypes
                    },
                    sentences: {
                        enabled: true,
                        types: sentenceTypes
                    }
                },
                sections: [
                    {
                        sectionId: docId + 'Section',
                        content: AppState.blocks
                    }
                ]
            };
        }

        function showFullDocument() {
            const doc = buildFullDocument();
            document.getElementById('jsonViewer').textContent = JSON.stringify(doc, null, 2);
        }

        function showBlocksOnly() {
            if (AppState.blocks.length > 0) {
                const lastBlock = AppState.blocks[AppState.blocks.length - 1];
                document.getElementById('jsonViewer').textContent = JSON.stringify(lastBlock, null, 2);
            }
        }

        // ==================== UTILITY FUNCTIONS ====================

        function setDataType(type) {
            AppState.dataType = type;
            document.getElementById('radioWord').classList.remove('selected');
            document.getElementById('radioParagraph').classList.remove('selected');
            document.getElementById(`radio${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.add('selected');

            const instruction = document.getElementById('instructionText');
            if (type === 'word') {
                instruction.innerHTML = 'Separate words with <kbd>space</kbd>. Example: ‡∏Å‡∏¥‡∏ô ‡∏î‡∏∑‡πà‡∏° ‡∏î‡∏π ‡∏ü‡∏±‡∏á ‡∏ï‡∏∑‡πà‡∏ô';
            } else {
                instruction.innerHTML = 'Separate sentences with <kbd>new lines</kbd>. Words within sentences with <kbd>space</kbd>. Example: ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö<br>‡∏ú‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏≠‡∏´‡πå‡∏ô<br>‡∏Ñ‡∏∏‡∏ì‡∏™‡∏ö‡∏≤‡∏¢‡∏î‡∏µ‡πÑ‡∏´‡∏°';
            }
        }

        function handleTagKeyPress(e) {
            if (e.key === 'Enter') {
                const input = document.getElementById('newTag');
                const tag = input.value.trim();
                if (tag) {
                    addTag(tag);
                    input.value = '';
                }
            }
        }

        function addTag(tag) {
            const container = document.getElementById('tagsContainer');
            const tagEl = document.createElement('span');
            tagEl.className = 'tag';
            tagEl.innerHTML = `${tag} <span class="material-icons" style="font-size: 14px; cursor: pointer;" onclick="this.parentElement.remove()">close</span>`;
            container.insertBefore(tagEl, document.getElementById('newTag'));
        }

        function getTags() {
            const tags = [];
            document.querySelectorAll('.tag').forEach(t => {
                tags.push(t.textContent.replace('close', '').trim());
            });
            return tags;
        }

        function updateStats() {
            const text = document.getElementById('thaiInput').value;
            if (AppState.dataType === 'word') {
                const words = text.split(/\s+/).filter(w => w.trim().length > 0);
                document.getElementById('wordCount').textContent = words.length;
                document.getElementById('sentenceCount').textContent = 'N/A';
            } else {
                const sentences = text.split('\n').filter(s => s.trim().length > 0);
                const words = text.split(/\s+/).filter(w => w.trim().length > 0);
                document.getElementById('wordCount').textContent = words.length;
                document.getElementById('sentenceCount').textContent = sentences.length;
            }
        }

        function cleanText() {
            const textarea = document.getElementById('thaiInput');
            textarea.value = Cleaner.clean(textarea.value);
            updateStats();
        }

        function removeBlock(index) {
            if (confirm('Remove this block?')) {
                AppState.blocks.splice(index, 1);
                updateBlocksDisplay();
                showFullDocument();
            }
        }

        function switchPreview(mode) {
            document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            if (mode === 'full') {
                showFullDocument();
            } else if (mode === 'blocks') {
                if (AppState.blocks.length > 0) {
                    const lastBlock = AppState.blocks[AppState.blocks.length - 1];
                    document.getElementById('jsonViewer').textContent = JSON.stringify(lastBlock, null, 2);
                } else {
                    document.getElementById('jsonViewer').textContent = '{}';
                }
            } else if (mode === 'vocab') {
                document.getElementById('jsonViewer').textContent = JSON.stringify(AppState.mainVocabulary, null, 2);
            } else if (mode === 'cache') {
                document.getElementById('jsonViewer').textContent = JSON.stringify(AppState.cacheVocabulary, null, 2);
            }
        }

        function downloadJSON(type) {
            let data;
            let filename;

            if (type === 'full') {
                data = buildFullDocument();
                filename = `${document.getElementById('docId').value}_full.json`;
            } else {
                if (AppState.blocks.length === 0) {
                    alert('No blocks to download');
                    return;
                }
                data = AppState.blocks[AppState.blocks.length - 1];
                filename = `${document.getElementById('docId').value}_block_${AppState.blocks.length}.json`;
            }

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function copyPreview() {
            const text = document.getElementById('jsonViewer').textContent;
            if (text && text !== '{}') {
                navigator.clipboard.writeText(text);
 //               alert('Preview copied to clipboard!');
            }
        }

        function clearPreview() {
            document.getElementById('jsonViewer').textContent = '';
        }

        function loadFile() {
            const file = document.getElementById('fileInput').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    document.getElementById('importJson').value = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        function copyToClipboard() {
            const text = document.getElementById('importJson').value;
            if (text) {
                navigator.clipboard.writeText(text);
 //               alert('Copied to clipboard!');
            }
        }

        function clearImport() {
            document.getElementById('importJson').value = '';
        }

        // Event listeners
        document.getElementById('thaiInput').addEventListener('input', updateStats);

        // Initialize
        init();

        // Make functions global
        window.setDataType = setDataType;
        window.cleanText = cleanText;
        window.downloadJSON = downloadJSON;
        window.switchPreview = switchPreview;
        window.removeBlock = removeBlock;
        window.handleTagKeyPress = handleTagKeyPress;
        window.loadFile = loadFile;
        window.importDocument = importDocument;
        window.initializeNewDocument = initializeNewDocument;
        window.updateVocabulary = updateVocabulary;
        window.generateBlock = generateBlock;
        window.checkDuplicates = checkDuplicates;
        window.addTag = addTag;
        window.copyToClipboard = copyToClipboard;
        window.clearImport = clearImport;
        window.copyPreview = copyPreview;
        window.clearPreview = clearPreview;
    </script>
</body>

</html>